<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Import 8-bit font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ear Training EQ Game</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- Babel for in-browser JSX transpiling (demo only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* no scrollbars */
      }
      body {
        background: black;
        color: white;
        font-family: 'Press Start 2P', cursive;
      }
      /* Top left: score; top right: hi-score */
      .scoreDisplay {
        font-size: 0.85rem; /* Base size for portrait mode */
        color: yellow;
        font-family: 'Press Start 2P', cursive;
        position: absolute;
        top: 4px;
        left: 4px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .hiScoreDisplay {
        font-size: 0.85rem; /* Base size for portrait mode */
        color: yellow;
        font-family: 'Press Start 2P', cursive;
        position: absolute;
        top: 4px;
        right: 4px;
        text-align: right;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      
      /* Responsive font scaling for scores based on screen width */
      @media (min-width: 600px) {
        .scoreDisplay, .hiScoreDisplay {
          font-size: 1rem; /* Bigger on medium screens */
        }
      }
      
      @media (min-width: 900px) {
        .scoreDisplay, .hiScoreDisplay {
          font-size: 1.2rem; /* Even bigger on large screens */
        }
      }
      
      @media (min-width: 1200px) {
        .scoreDisplay, .hiScoreDisplay {
          font-size: 1.4rem; /* Largest on very large screens */
          top: 8px; /* More spacing at top on large screens */
        }
        .scoreDisplay {
          left: 8px; /* More spacing at left on large screens */
        }
        .hiScoreDisplay {
          right: 8px; /* More spacing at right on large screens */
        }
      }
      
      /* File input container */
      .fileInputContainer {
        text-align: center;
        margin-top: 20px;
        margin-bottom: 10px;
      }
      .fileInputContainer input[type="file"] {
        width: 0.1px;
        height: 0.1px;
        opacity: 0;
        overflow: hidden;
        position: absolute;
        z-index: -1;
      }
      .fileInputContainer .fileInputLabel {
        display: inline-block;
        padding: 8px 16px;
        cursor: pointer;
        background-color: #3b82f6;
        color: white;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.8rem;
        border-radius: 4px;
        border: none;
        text-shadow: 1px 1px 0px #000;
        box-shadow: 0 4px 0 #2563eb;
      }
      .fileInputContainer .fileInputLabel:hover {
        background-color: #2563eb;
      }
      .fileInputContainer .fileInputLabel:active {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #2563eb;
      }
      .fileInputContainer .fileName {
        display: block;
        margin-top: 8px;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.7rem;
        color: yellow;
        text-align: center;
      }
      /* EQ container & panel */
      .eqContainer {
        position: relative;
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        margin-top: 60px; /* Reduced to account for file input below */
        display: flex;
        flex-direction: column;
        align-items: center; /* Center the panel */
      }
      .eqPanel {
        position: relative;
        width: auto; /* Auto width instead of 100% */
        height: 280px; /* Reduced from 300px by 20px */
        background: #1e3a8a;
        border-radius: 8px;
        padding: 20px 15px; /* More padding to accommodate screws */
        overflow: hidden;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        position: relative; /* Ensure proper positioning context */
        min-width: 220px; /* Ensure panel doesn't get too small */
      }
      /* Screw styling for the corners */
      .screw {
        position: absolute;
        font-size: 20px;
        color: black;
        line-height: 1;
        width: 20px;
        height: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 15; /* Higher than the panel but lower than overlays */
      }
      .screw-top-left {
        top: 5px;
        left: 5px;
      }
      .screw-top-right {
        top: 5px;
        right: 5px;
      }
      .screw-bottom-left {
        bottom: 5px;
        left: 5px;
      }
      .screw-bottom-right {
        bottom: 5px;
        right: 5px;
      }

      /* Custom styles for slider thumbs - making them bigger and black */
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;  /* Increased from 16px */
        height: 20px; /* Increased from 16px */
        background: black;
        border-radius: 50%;
        cursor: pointer;
        border: 1px solid #444;
      }
      
      input[type="range"]::-moz-range-thumb {
        width: 20px;  /* Increased from 16px */
        height: 20px; /* Increased from 16px */
        background: black;
        border-radius: 50%;
        cursor: pointer;
        border: 1px solid #444;
      }
      
      input[type="range"]::-ms-thumb {
        width: 20px;  /* Increased from 16px */
        height: 20px; /* Increased from 16px */
        background: black;
        border-radius: 50%;
        cursor: pointer;
        border: 1px solid #444;
      }
      
      /* Fix overlay positioning to make them visible on top of panel */
      .countdownOverlay,
      .feedbackOverlay,
      .hintOverlay {
        position: fixed; /* Changed from absolute to fixed */
        top: 25%; /* Position above the EQ sliders instead of directly in the middle */
        left: 50%;
        transform: translate(-50%, -50%); /* Center horizontally */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100; /* Increased z-index significantly */
        pointer-events: none;
        width: auto; /* Allow width to fit content */
        min-width: 80%;
        text-align: center;
      }
      
      .countdownOverlay {
        font-size: 5rem;
        color: yellow;
        font-family: 'Press Start 2P', cursive;
        background: rgba(0, 0, 0, 0.7); /* More opaque background */
        padding: 40px;
        border-radius: 20px;
        text-shadow: 4px 4px 0px #000;
      }
      
      .feedbackOverlay {
        font-size: 3rem;
        color: yellow;
        font-family: 'Press Start 2P', cursive;
        animation: zoomIn 0.2s forwards, fadeOut 0.5s 1.5s forwards; /* Extended duration */
        background: rgba(0, 0, 0, 0.8); /* More opaque background */
        padding: 30px 40px;
        border-radius: 20px;
        text-shadow: 3px 3px 0px #000;
      }
      
      .hintOverlay {
        flex-direction: column;
        font-size: 2.8rem;
        color: #ff3333;
        text-shadow: 3px 3px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000;
        font-family: 'Press Start 2P', cursive;
        text-transform: uppercase;
        font-weight: bold;
        text-align: center;
        line-height: 1.5;
        padding: 30px;
        background-color: rgba(0, 0, 0, 0.85);
        animation: pulseBig 0.5s infinite alternate;
        border-radius: 20px;
        position: fixed; /* Ensure it's fixed position */
        top: 15%; /* Position it above the panel, not at 25% */
        z-index: 200; /* Increase z-index to be above everything */
      }
      
      @keyframes pulseBig {
        from { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        to { transform: translate(-50%, -50%) scale(1.1); opacity: 0.9; }
      }
      
      @keyframes zoomIn {
        from { transform: translate(-50%, -50%) scale(0.7); opacity: 0.7; }
        to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      }
      
      @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; visibility: hidden; }
      }
      /* Bottom controls: two horizontal sliders */
      .bottomControls {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 16px;
        z-index: 10;
      }
      .bottomSlider {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .bottomSlider label {
        font-family: 'Press Start 2P', cursive;
        font-size: 0.75rem;
        margin-bottom: 4px;
      }
      input[type="range"] {
        cursor: pointer;
        font-family: 'Press Start 2P', cursive;
      }
      /* Transport controls */
      .transportControls {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin: 10px 0;
      }
      .playlistContainer {
        width: 80%;
        margin: 0 auto;
        max-height: 150px;
        overflow-y: auto;
        background: #222;
        border-radius: 4px;
        padding: 8px;
      }
      .playlistItem {
        padding: 6px;
        border-bottom: 1px solid #444;
        cursor: pointer;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.7rem;
      }
      .playlistItem.active {
        background: #3b82f6;
      }
      .trackSlider {
        width: 80%;
        margin: 10px auto;
      }>
      .trackInfo {
        display: flex;
        justify-content: space-between;
        width: 80%;
        margin: 0 auto;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.75rem;
        color: #888;
      }
      .modalOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
      }
      .modalContent {
        background: #1e3a8a;
        border: 4px solid yellow;
        padding: 20px 30px;
        border-radius: 8px;
        text-align: center;
        min-width: 300px;
      }
      .modalContent h2 {
        font-family: 'Press Start 2P', cursive;
        color: yellow;
        margin-top: 0;
      }
      .modalContent p {
        font-family: 'Press Start 2P', cursive;
        font-size: 0.9rem;
        margin: 20px 0;
      }
      
      /* Instructions modal styles */
      .instructionsModal {
        background: #1e3a8a;
        border: 4px solid #ff3333;
        padding: 20px 30px;
        border-radius: 8px;
        text-align: left;
        max-width: 80%;
        max-height: 80vh;
        overflow-y: auto;
      }
      .instructionsModal h2 {
        font-family: 'Press Start 2P', cursive;
        color: #ff3333;
        margin-top: 0;
        text-align: center;
        text-transform: uppercase;
        text-shadow: 2px 2px 0px #000;
      }
      .instructionsModal p {
        font-family: 'Press Start 2P', cursive;
        font-size: 0.8rem;
        margin: 15px 0;
        line-height: 1.5;
        color: white;
      }
      .instructionsModal strong {
        color: yellow;
      }
      .instructionsModal .highlight {
        color: #22c55e;
        font-weight: bold;
      }
      .instructionsModal .warning {
        color: #ff3333;
        font-weight: bold;
      }
      .instructionsModal ul {
        margin: 10px 0;
        padding-left: 20px;
      }
      .instructionsModal li {
        font-family: 'Press Start 2P', cursive;
        font-size: 0.8rem;
        margin: 10px 0;
        color: white;
      }
      .instructionsNav {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
      }
      .instructionsPageIndicator {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 15px;
      }
      .pageIndicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #555;
        cursor: pointer;
      }
      .pageIndicator.active {
        background-color: #ff3333;
        transform: scale(1.2);
      }
      .instructionsButton {
        padding: 8px 12px;
        background-color: #ff3333;
        color: white;
        border: none;
        border-radius: 4px;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.7rem;
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 0 4px 0 #990000;
      }
      .instructionsButton:hover {
        background-color: #ff5555;
      }
      .instructionsButton:active {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #990000;
      }
      .instructionsButton.disabled {
        background-color: #555;
        cursor: not-allowed;
        box-shadow: none;
      }
      
      .modalButtons {
        display: flex;
        justify-content: center;
        gap: 20px;
      }
      .shuffleButton {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-left: 8px;
      }

      /* Media query for responsive button labels */
      @media (orientation: portrait) {
        .button-text-full {
          display: none;
        }
        .button-text-short {
          display: inline;
        }
      }
      
      @media (orientation: landscape) {
        .button-text-full {
          display: inline;
        }
        .button-text-short {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      // Global frequencies.
      const frequencies = {
        3: [
          { label: "100", value: 100 },
          { label: "1k", value: 1000 },
          { label: "10k", value: 10000 }
        ],
        5: [
          { label: "80", value: 80 },
          { label: "250", value: 250 },
          { label: "1k", value: 1000 },
          { label: "4k", value: 4000 },
          { label: "10k", value: 10000 }
        ],
        10: [
          { label: "31", value: 31 },
          { label: "63", value: 63 },
          { label: "125", value: 125 },
          { label: "250", value: 250 },
          { label: "500", value: 500 },
          { label: "1k", value: 1000 },
          { label: "2k", value: 2000 },
          { label: "4k", value: 4000 },
          { label: "8k", value: 8000 },
          { label: "16k", value: 16000 }
        ],
        13: [
          { label: "25", value: 25 },
          { label: "40", value: 40 },
          { label: "63", value: 63 },
          { label: "100", value: 100 },
          { label: "160", value: 160 },
          { label: "250", value: 250 },
          { label: "400", value: 400 },
          { label: "630", value: 630 },
          { label: "1k", value: 1000 },
          { label: "1.6k", value: 1600 },
          { label: "2.5k", value: 2500 },
          { label: "6.3k", value: 6300 },
          { label: "16k", value: 16000 }
        ],
        16: [
          { label: "20", value: 20 },
          { label: "31", value: 31 },
          { label: "50", value: 50 },
          { label: "80", value: 80 },
          { label: "125", value: 125 },
          { label: "200", value: 200 },
          { label: "315", value: 315 },
          { label: "500", value: 500 },
          { label: "800", value: 800 },
          { label: "1.25k", value: 1250 },
          { label: "2k", value: 2000 },
          { label: "3.15k", value: 3150 },
          { label: "5k", value: 5000 },
          { label: "8k", value: 8000 },
          { label: "12.5k", value: 12500 },
          { label: "20k", value: 20000 }
        ],
        19: [
          { label: "20", value: 20 },
          { label: "25", value: 25 },
          { label: "31", value: 31 },
          { label: "40", value: 40 },
          { label: "50", value: 50 },
          { label: "63", value: 63 },
          { label: "80", value: 80 },
          { label: "100", value: 100 },
          { label: "125", value: 125 },
          { label: "250", value: 250 },
          { label: "500", value: 500 },
          { label: "1k", value: 1000 },
          { label: "2k", value: 2000 },
          { label: "4k", value: 4000 },
          { label: "8k", value: 8000 },
          { label: "12.5k", value: 12500 },
          { label: "16k", value: 16000 },
          { label: "18k", value: 18000 },
          { label: "20k", value: 20000 }
        ],
        22: [
          { label: "20", value: 20 },
          { label: "25", value: 25 },
          { label: "31", value: 31 },
          { label: "40", value: 40 },
          { label: "50", value: 50 },
          { label: "63", value: 63 },
          { label: "80", value: 80 },
          { label: "100", value: 100 },
          { label: "125", value: 125 },
          { label: "160", value: 160 },
          { label: "200", value: 200 },
          { label: "250", value: 250 },
          { label: "500", value: 500 },
          { label: "1k", value: 1000 },
          { label: "2k", value: 2000 },
          { label: "3.15k", value: 3150 },
          { label: "4k", value: 4000 },
          { label: "6.3k", value: 6300 },
          { label: "8k", value: 8000 },
          { label: "10k", value: 10000 },
          { label: "16k", value: 16000 },
          { label: "20k", value: 20000 }
        ],
        25: [
          { label: "20", value: 20 },
          { label: "25", value: 25 },
          { label: "31", value: 31 },
          { label: "40", value: 40 },
          { label: "50", value: 50 },
          { label: "63", value: 63 },
          { label: "80", value: 80 },
          { label: "100", value: 100 },
          { label: "125", value: 125 },
          { label: "160", value: 160 },
          { label: "200", value: 200 },
          { label: "250", value: 250 },
          { label: "315", value: 315 },
          { label: "400", value: 400 },
          { label: "500", value: 500 },
          { label: "800", value: 800 },
          { label: "1k", value: 1000 },
          { label: "1.6k", value: 1600 },
          { label: "2.5k", value: 2500 },
          { label: "4k", value: 4000 },
          { label: "6.3k", value: 6300 },
          { label: "10k", value: 10000 },
          { label: "12.5k", value: 12500 },
          { label: "16k", value: 16000 },
          { label: "20k", value: 20000 }
        ],
        28: [
          { label: "20", value: 20 },
          { label: "25", value: 25 },
          { label: "31", value: 31 },
          { label: "40", value: 40 },
          { label: "50", value: 50 },
          { label: "63", value: 63 },
          { label: "80", value: 80 },
          { label: "100", value: 100 },
          { label: "125", value: 125 },
          { label: "160", value: 160 },
          { label: "200", value: 200 },
          { label: "250", value: 250 },
          { label: "315", value: 315 },
          { label: "400", value: 400 },
          { label: "500", value: 500 },
          { label: "630", value: 630 },
          { label: "800", value: 800 },
          { label: "1k", value: 1000 },
          { label: "1.25k", value: 1250 },
          { label: "1.6k", value: 1600 },
          { label: "2k", value: 2000 },
          { label: "2.5k", value: 2500 },
          { label: "4k", value: 4000 },
          { label: "6.3k", value: 6300 },
          { label: "10k", value: 10000 },
          { label: "12.5k", value: 12500 },
          { label: "16k", value: 16000 },
          { label: "20k", value: 20000 }
        ],
        31: [
          { label: "20", value: 20 },
          { label: "25", value: 25 },
          { label: "31", value: 31 },
          { label: "40", value: 40 },
          { label: "50", value: 50 },
          { label: "63", value: 63 },
          { label: "80", value: 80 },
          { label: "100", value: 100 },
          { label: "125", value: 125 },
          { label: "160", value: 160 },
          { label: "200", value: 200 },
          { label: "250", value: 250 },
          { label: "315", value: 315 },
          { label: "400", value: 400 },
          { label: "500", value: 500 },
          { label: "630", value: 630 },
          { label: "800", value: 800 },
          { label: "1k", value: 1000 },
          { label: "1.25k", value: 1250 },
          { label: "1.6k", value: 1600 },
          { label: "2k", value: 2000 },
          { label: "2.5k", value: 2500 },
          { label: "3.15k", value: 3150 },
          { label: "4k", value: 4000 },
          { label: "5k", value: 5000 },
          { label: "6.3k", value: 6300 },
          { label: "8k", value: 8000 },
          { label: "10k", value: 10000 },
          { label: "12.5k", value: 12500 },
          { label: "16k", value: 16000 },
          { label: "20k", value: 20000 }
        ]
      };

      // Frequency descriptors for hints
      const freqDescriptors = {
        20: "LOW END",
        25: "LOW END",
        31: "LOW END",
        40: "LOW END",
        50: "WEIGHT",
        63: "GROWL",
        80: "BOOM",
        100: "BOOM",
        125: "CHUNK",
        160: "THICKNESS",
        200: "MUD",
        250: "BOXINESS",
        315: "WOOF",
        400: "HONK",
        500: "HONK",
        630: "WOOD",
        800: "PUNCH",
        1000: "BITE",
        1250: "EDGE",
        1600: "SIZZLE",
        2000: "SNAP",
        2500: "PRESENCE",
        3150: "HISS",
        4000: "CRISPINESS",
        5000: "FIZZ",
        6300: "SPARKLE",
        8000: "AIR",
        10000: "SHIMMER",
        12500: "HIGH END",
        16000: "HIGH END",
	      18000: "HIGH END",
        20000: "HIGH END",
      };

      // Array of heckling messages when player loses a life
      const hecklingMessages = [
        "YOU SUCK!",
        "BOO!",
        "IS THE SOUND GUY DRUNK?",
        "GO HOME!",
        "MY FREAKING EARS!",
        "YOU CALL YOURSELF A SOUNDTECH?",
        "YOU'RE RUINING THE SHOW!",
        "YOU'RE NOT AS GOOD AS NIGEL!",
        "YOU CALL THIS A MIX?",
        "YOU'RE RUINING MY NIGHT!",
      ];

      // Button component.
      function Button({ onClick, children, disabled = false, style = {} }) {
        return (
          <button
            onClick={onClick}
            disabled={disabled}
            style={{
              padding: "8px 16px",
              margin: "4px",
              cursor: disabled ? "not-allowed" : "pointer",
              border: "none",
              borderRadius: "4px",
              backgroundColor: disabled ? "#6b7280" : "#3b82f6",
              color: "white",
              fontFamily: "'Press Start 2P', cursive",
              fontSize: "0.8rem",
              opacity: disabled ? 0.7 : 1,
              textShadow: "1px 1px 0px #000",
              boxShadow: disabled ? "none" : "0 4px 0 #2563eb",
              ...style
            }}
          >
            {children}
          </button>
        );
      }

      // Volume slider component (horizontal) for master volume (0 to 10)
      function VolumeSlider({ value, onChange }) {
        return (
          <div className="bottomSlider">
            <label>Volume</label>
            <input
              type="range"
              min="0"
              max="10"
              step="1"
              value={value}
              onChange={onChange}
              style={{ width: "200px" }}
            />
          </div>
        );
      }

      // Use the same slider component for Room Ambiance and Crowd Ambiance.
      function AmbianceSlider({ label, value, onChange, min, max, step }) {
        return (
          <div className="bottomSlider">
            <label>{label}</label>
            <input
              type="range"
              min={min}
              max={max}
              step={step}
              value={value}
              onChange={onChange}
              style={{ width: "200px" }}
            />
          </div>
        );
      }

      const { useState, useEffect, useRef } = React;

      // Audio prompt component
      const AudioPrompt = () => (
        <div className="modalOverlay">
          <div className="modalContent">
            <h2>Dive Bar Simulator</h2>
            <p>Please select audio files to start the game</p>
            <div className="fileInputContainer" style={{ margin: '20px 0' }}>
              <label htmlFor="initialFileInput" className="fileInputLabel">
                Choose Audio Files
              </label>
              <input 
                id="initialFileInput"
                type="file" 
                accept="audio/*,video/*" 
                onChange={(e) => {
                  handleFilesChange(e);
                  setShowAudioPrompt(false);
                }} 
                multiple 
              />
            </div>
          </div>
        </div>
      );
      
      // Instructions modal component with multiple pages
      const InstructionsModal = ({ onClose }) => {
        const [currentPage, setCurrentPage] = useState(0);
        
        // Content for each instruction page
        const pages = [
          // Page 1: Basic Game Info & Controls
          <>
            <h2>DIVE BAR SIMULATOR!</h2>
            <p>Listen up, kid! We've had a lot of "Sound Techs" come through The Hell and Hole. The EQ on the PA is garbage, the crowd is drunk, You've got one job!</p>
            <p><strong>YOUR MISSION:</strong> Fix the sound by moving the <span className="highlight">CORRECT SLIDER</span> to undo whatever hellish frequency the performer throws at you</p>
            <p><strong>CONTROLS:</strong></p>
            <ul>
              <li>Drag the <span className="highlight">SLIDERS</span> up (boost) or down (cut) to fix the sound</li>
              <li>Hit the <span className="highlight">REF BUTTON</span> to hear how the track SHOULD sound (no EQ)</li>
                         </ul>
          </>,
          
          // Page 2: Difficulty Levels & Gameplay Features
          <>
            <h2>DIFFICULTY & SPECIAL MODES</h2>
            <ul>
              <li><span style={{color: "#22c55e"}}>GREEN</span>: EASY MODE - For total newbies (10-12dB changes)</li>
              <li><span style={{color: "#f97316"}}>ORANGE</span>: MEDIUM MODE - Default setting (6-10dB changes)</li>
              <li><span style={{color: "#ef4444"}}>RED</span>: HARD MODE - For audio nerds with god-like ears (3-6dB changes)</li>
              <li><span style={{color: "#9333ea"}}>PURPLE</span>: LO-FI MODE - Only uses mid-range frequencies for laptops / phones speakers (250Hz-10kHz)</li>
            </ul>
            
            <p><strong>HOW TO WIN:</strong></p>
            <p>Move the <span className="highlight">correct slider</span> in the <span className="highlight">right direction</span> close enough to the target value. The closer you get, the more points you earn!</p>
            
          
            <p><strong>HINTS:</strong> After your first couple wrong attempt, you'll get a frequency hint like "TOO MUCH BOOM" or "NOT ENOUGH BITE" to guide you!</p>
          </>,
          
          // Page 3: Feedback Mode & Advanced Features
          <>
            <h2>FEEDBACK</h2>
            <p><span className="warning">DANGER! FEEDBACK ALERT!</span> If you fail three times on a slider, <span className="warning">FEEDBACK</span> will erupt! The whole bar will hate you!</p>
            <ul>
              <li>Quickly find the <span className="highlight">EXACT SLIDER</span> causing feedback</li>
              <li>Pull that slider <span className="highlight">DOWN at least 3dB</span> to kill the feedback</li>
              <li>Move the <span className="warning">WRONG SLIDER</span> and lose a life!</li>
              <li>Too slow? Lose a life!</li>
            </ul>
            
            <p><strong>PRO TIPS:</strong></p>
            <ul>
              <li>Use the <span className="highlight">crowd noise slider</span> at the bottom for extra distraction</li>
              <li>Add <span className="highlight">reverb</span> to simulate that classic dive bar echo</li>
              <li>Load <span className="highlight">multiple audio files</span> for variety</li>
            </ul>
            <p>If you enjoy this silly game please consider buying me s coffee! https://paypal.me/jamesmulvale</p>
            <p>Ready?</p>
          </>
        ];
        
        const goToNextPage = () => {
          if (currentPage < pages.length - 1) {
            setCurrentPage(currentPage + 1);
          } else {
            onClose();
          }
        };
        
        const goToPrevPage = () => {
          if (currentPage > 0) {
            setCurrentPage(currentPage - 1);
          }
        };
        
        const goToPage = (pageNum) => {
          if (pageNum >= 0 && pageNum < pages.length) {
            setCurrentPage(pageNum);
          }
        };
        
        return (
          <div className="modalOverlay">
            <div className="instructionsModal">
              {pages[currentPage]}
              
              <div className="instructionsNav">
                <button 
                  className={`instructionsButton ${currentPage === 0 ? 'disabled' : ''}`}
                  onClick={goToPrevPage}
                  disabled={currentPage === 0}
                >
                  Back
                </button>
                
                <button 
                  className="instructionsButton"
                  onClick={goToNextPage}
                >
                  {currentPage === pages.length - 1 ? "Let's Rock!" : "Next"}
                </button>
              </div>
              
              <div className="instructionsPageIndicator">
                {pages.map((_, index) => (
                  <div 
                    key={index} 
                    className={`pageIndicator ${currentPage === index ? 'active' : ''}`}
                    onClick={() => goToPage(index)}
                  />
                ))}
              </div>
            </div>
          </div>
        );
      };

      function App() {
        // State variables.
        const [level, setLevel] = useState(1);
        const [hiScore, setHiScore] = useState(0);
        const [totalScore, setTotalScore] = useState(0);
        const [sliders, setSliders] = useState([]);
        const [targetMods, setTargetMods] = useState([]);
        const [countdownText, setCountdownText] = useState("");
        const [countdownActive, setCountdownActive] = useState(false);
        const [roundTime, setRoundTime] = useState(30);
        const [attemptsLeft, setAttemptsLeft] = useState(3);
        const [feedback, setFeedback] = useState("");
        const [roundScore, setRoundScore] = useState(null);
        const [isPlaying, setIsPlaying] = useState(false);
        const [startTime, setStartTime] = useState(null);
        const [isShowingReference, setIsShowingReference] = useState(false);
        const [roundStarted, setRoundStarted] = useState(false);
        
        // First-load instructions state
        const [showInstructions, setShowInstructions] = useState(true);
        
        // Audio prompt state - only show after instructions are closed
        const [showAudioPrompt, setShowAudioPrompt] = useState(false);
        
        // Debug mode state - dots hidden by default
        const [debugMode, setDebugMode] = useState(false);
        
        // Add second crowd audio ref for crossfading
        const secondaryCrowdAudioRef = useRef(null);
        const isCrossfadingRef = useRef(false);
        
        // Feedback eliminator state
        const [feedbackActive, setFeedbackActive] = useState(false);
        const [feedbackSliderIndex, setFeedbackSliderIndex] = useState(null);
        const [lives, setLives] = useState(3);
        const [gameOver, setGameOver] = useState(false);
        const [sliderInteractionDisabled, setSliderInteractionDisabled] = useState(false);

        // Modified state variables to track reference state
        const [isReferenceActive, setIsReferenceActive] = useState(false);
        const referenceFlashTimerRef = useRef(null);

        // Difficulty settings
        const [difficulty, setDifficulty] = useState('medium'); // 'easy', 'medium', or 'hard'
        const difficultySettings = {
          easy: { min: 10, max: 12 }, // 10-12 dB
          medium: { min: 6, max: 10 }, // 6-10 dB
          hard: { min: 3, max: 6 }    // 3-6 dB
        };

        // Feedback mode state
        const [feedbackMode, setFeedbackMode] = useState(false);

        // Global controls.
        const [masterVolume, setMasterVolume] = useState(5); // Start at 50% (5 out of 10)
        const [roomAmbiance, setRoomAmbiance] = useState(0.2); // Start at 20%
        const [crowdVolume, setCrowdVolume] = useState(0.25); // Start at 25% (changed from 10%)

        // Audio player state
        const [audioFiles, setAudioFiles] = useState([]);
        const [currentTrackIndex, setCurrentTrackIndex] = useState(0);
        const [audioPlayerState, setAudioPlayerState] = useState('stopped');
        const [trackPosition, setTrackPosition] = useState(0);
        const [trackDuration, setTrackDuration] = useState(0);
        const [isUpdatingPosition, setIsUpdatingPosition] = useState(false);
        const trackPositionTimerRef = useRef(null);

        // State for showing frequency hint
        const [showingFrequencyHint, setShowingFrequencyHint] = useState(false);
        const [frequencyHintText, setFrequencyHintText] = useState("");

        // Lo-fi mode toggle
        const [lofiMode, setLofiMode] = useState(false);

        // Band selection history
        const [bandSelectionHistory, setBandSelectionHistory] = useState([]);

        // Determine active band count & frequency preset based on the revised progression
        const getActiveBandCount = (level) => {
          // Check if we're in portrait mode (mobile)
          const isPortrait = window.innerHeight > window.innerWidth;
          
          if (isPortrait) {
            // In portrait mode, cap at 10 bands max
            if (level <= 5) return 3;         // Level 1-1 to 1-5: 3 bands
            if (level <= 10) return 5;        // Level 2-1 to 2-5: 5 bands
            return 10;                        // Level 3-1 and beyond: stay at 10 bands
          } else {
            // In landscape mode (PC), use full progression
            if (level <= 5) return 3;         // Level 1-1 to 1-5: 3 bands
            if (level <= 10) return 5;        // Level 2-1 to 2-5: 5 bands
            if (level <= 15) return 10;       // Level 3-1 to 3-5: 10 bands
            if (level <= 20) return 13;       // Level 4-1 to 4-5: 13 bands
            if (level <= 25) return 16;       // Level 5-1 to 5-5: 16 bands
            if (level <= 30) return 19;       // Level 6-1 to 6-5: 19 bands
            if (level <= 35) return 22;       // Level 7-1 to 7-5: 22 bands
            if (level <= 40) return 25;       // Level 8-1 to 8-5: 25 bands
            if (level <= 45) return 28;       // Level 9-1 to 9-5: 28 bands
            return 31;                        // Level 10-1 and beyond: 31 bands
          }
        };
        
        // Calculate stage and round numbers for display
        const getStageRound = (level) => {
          const isPortrait = window.innerHeight > window.innerWidth;
          
          if (isPortrait && level > 15) {
            // In portrait mode, after level 15 (3-5), continue with stage 3
            // but increase the round number beyond 5
            return { 
              stage: 3,
              round: ((level - 15) + 5) // Start from round 6 after level 3-5
            };
          } else {
            // Standard calculation for landscape or early levels
            const stage = Math.floor((level - 1) / 5) + 1;
            const round = ((level - 1) % 5) + 1;
            return { stage, round };
          }
        };

        // Calculate active band count using the new function
        const activeBandCount = getActiveBandCount(level);
        const stageRound = getStageRound(level);
        const freqArray = frequencies[activeBandCount];

        // Audio refs.
        const audioContextRef = useRef(null);
        const audioSourceRef = useRef(null);
        const gainNodeRef = useRef(null);
        const filtersRef = useRef([]);
        const audioBuffersRef = useRef([]);
        const timerRef = useRef(null);

        // Echo effect (reverb) nodes.
        const delayNodeRef = useRef(null);
        const feedbackGainRef = useRef(null);
        const wetGainRef = useRef(null);

        // Crowd ambiance audio.
        const crowdAudioRef = useRef(null);

        // Track last slider interaction for auto-check
        const sliderTimeoutRef = useRef(null);
        const lastSliderChangeRef = useRef(Date.now());

        // Feedback oscillator refs
        const feedbackOscillatorRef = useRef(null);
        const feedbackGainNodeRef = useRef(null);
        const feedbackLFORef = useRef(null);

        // Initial setup effect
        useEffect(() => {
          // Initialize crowd audio with CROWDNOISE.mp3
          if (crowdAudioRef.current) {
            crowdAudioRef.current.src = "CROWDNOISE.mp3"; // Use local file instead of base64
            crowdAudioRef.current.load(); // Force reload with the new source
            crowdAudioRef.current.volume = crowdVolume;
            
            // Set up crossfade looping when loaded
            crowdAudioRef.current.addEventListener('loadeddata', setupCrowdNoiseLooping);
          }
          
          // Create secondary crowd audio element
          const secondaryAudio = new Audio("CROWDNOISE.mp3");
          secondaryAudio.volume = 0;
          secondaryCrowdAudioRef.current = secondaryAudio;
          
          return () => {
            // Cleanup
            if (timerRef.current) clearInterval(timerRef.current);
            if (trackPositionTimerRef.current) clearInterval(trackPositionTimerRef.current);
            if (audioContextRef.current && audioContextRef.current.state !== "closed") {
              audioContextRef.current.close();
            }
            
            // Clean up crowd audio elements
            if (crowdAudioRef.current) {
              crowdAudioRef.current.removeEventListener('loadeddata', setupCrowdNoiseLooping);
              crowdAudioRef.current.pause();
              crowdAudioRef.current = null;
            }
            
            if (secondaryCrowdAudioRef.current) {
              secondaryCrowdAudioRef.current.pause();
              secondaryCrowdAudioRef.current = null;
            }
            
            if (referenceFlashTimerRef.current) {
              clearInterval(referenceFlashTimerRef.current);
            }
            
            // Clean up oscillator on unmount
            stopFeedbackOscillator();
          };
        }, []);

        // Function to handle crowd noise looping with crossfading
        function setupCrowdNoiseLooping() {
          if (!crowdAudioRef.current) return;
          
          // Create secondary crowd audio element if it doesn't exist
          if (!secondaryCrowdAudioRef.current) {
            const secondaryAudio = new Audio("CROWDNOISE.mp3");
            secondaryAudio.volume = 0;
            secondaryCrowdAudioRef.current = secondaryAudio;
          }
          
          // Always ensure crowd audio has the current set volume level
          if (crowdAudioRef.current) {
            crowdAudioRef.current.volume = crowdVolume;
          }
          
          // Start playing crowd noise immediately if it has volume
          if (crowdVolume > 0 && crowdAudioRef.current.paused && crowdAudioRef.current.readyState >= 2) {
            try {
              crowdAudioRef.current.play()
                .catch(e => console.error("Error starting crowd audio:", e));
            } catch (e) {
              console.error("Error playing crowd audio:", e);
            }
          }
          
          // Make sure we remove any existing timeupdate listeners to prevent duplicates
          crowdAudioRef.current.removeEventListener('timeupdate', handleCrowdTimeUpdate);
          
          // Add the timeupdate listener
          crowdAudioRef.current.addEventListener('timeupdate', handleCrowdTimeUpdate);
          
          // Also add ended event listener as a fallback
          crowdAudioRef.current.addEventListener('ended', handleCrowdEnded);
          if (secondaryCrowdAudioRef.current) {
            secondaryCrowdAudioRef.current.addEventListener('ended', handleCrowdEnded);
          }
        }
        
        // Separate function for timeupdate handling to avoid duplicate listeners
        function handleCrowdTimeUpdate() {
          // Start crossfade when 5 seconds from the end
          if (!crowdAudioRef.current) return;
          
          const timeLeft = crowdAudioRef.current.duration - crowdAudioRef.current.currentTime;
          
          if (timeLeft <= 5 && !isCrossfadingRef.current && secondaryCrowdAudioRef.current) {
            console.log("Starting crowd crossfade");
            isCrossfadingRef.current = true;
            
            // Store the current crowd volume target to be restored at the end of crossfade
            // Important: Capture the latest state value, not a stale closure value
            const targetVolume = crowdVolume;
            console.log("Crossfade target volume:", targetVolume);
            
            // Start the secondary track
            secondaryCrowdAudioRef.current.volume = 0;
            secondaryCrowdAudioRef.current.currentTime = 0;
            secondaryCrowdAudioRef.current.play()
              .catch(e => console.error("Error starting secondary crowd track:", e));
            
            // Create crossfade effect
            const fadeInterval = setInterval(() => {
              if (!crowdAudioRef.current || !secondaryCrowdAudioRef.current) {
                clearInterval(fadeInterval);
                return;
              }
              
              // Gradually decrease volume of first track
              if (crowdAudioRef.current.volume > 0.01) {
                crowdAudioRef.current.volume = Math.max(0, crowdAudioRef.current.volume - 0.01);
              }
              
              // Gradually increase volume of second track up to the current crowd volume setting
              if (secondaryCrowdAudioRef.current.volume < targetVolume) {
                secondaryCrowdAudioRef.current.volume = Math.min(
                  targetVolume, 
                  secondaryCrowdAudioRef.current.volume + 0.01
                );
              }
              
              // When crossfade is complete, swap the tracks and reset
              if (crowdAudioRef.current.volume <= 0.01 && 
                  Math.abs(secondaryCrowdAudioRef.current.volume - targetVolume) < 0.02) {
                clearInterval(fadeInterval);
                
                // Stop the first track completely
                crowdAudioRef.current.pause();
                crowdAudioRef.current.currentTime = 0;
                
                // Remove timeupdate listener from old primary track
                crowdAudioRef.current.removeEventListener('timeupdate', handleCrowdTimeUpdate);
                
                // Swap references
                const temp = crowdAudioRef.current;
                crowdAudioRef.current = secondaryCrowdAudioRef.current;
                secondaryCrowdAudioRef.current = temp;
                
                // Add timeupdate listener to new primary track
                crowdAudioRef.current.addEventListener('timeupdate', handleCrowdTimeUpdate);
                
                // Ensure the volume is exactly set to the target volume
                crowdAudioRef.current.volume = targetVolume;
                
                // Reset crossfading flag
                isCrossfadingRef.current = false;
                
                console.log("Crowd crossfade complete, volume set to:", targetVolume);
              }
            }, 50); // Update every 50ms for smooth crossfade
          }
        }
        
        // Fallback handler if the audio ends without crossfade
        function handleCrowdEnded(event) {
          console.log("Crowd audio ended event triggered");
          
          // If this is the primary track ending
          if (event.target === crowdAudioRef.current && !isCrossfadingRef.current) {
            console.log("Primary crowd track ended without crossfade - restarting");
            
            // Just restart the track immediately
            crowdAudioRef.current.currentTime = 0;
            
            if (crowdVolume > 0) {
              crowdAudioRef.current.play()
                .catch(e => console.error("Error restarting crowd audio:", e));
            }
          }
        }

        // Apply filter gains in one centralized function
        function applyFilterGains(gainsArray) {
          if (!filtersRef.current) return;
          
          filtersRef.current.forEach((filter, i) => {
            if (filter) {
              filter.gain.value = gainsArray[i] || 0;
            }
          });
        }
        
        // Reset game state - useful for level changes and cleanup
        function resetGameState(fullReset = false) {
          // Reset sliders UI
          setSliders(new Array(activeBandCount).fill(0));
          
          // Reset feedback-related state
          setFeedback("");
          setFeedbackActive(false);
          setFeedbackMode(false);
          
          // Reset round state
          setRoundStarted(false);
          setIsPlaying(false);
          setCountdownActive(false);
          setTargetMods([]);
          setAttemptsLeft(3);
          setRoundTime(30);
          
          // Reset all filters to zero
          if (filtersRef.current) {
            applyFilterGains(new Array(filtersRef.current.length).fill(0));
          }
          
          // Full reset for game over
          if (fullReset) {
            setLives(3);
            setTotalScore(0);
            setLevel(1);
            handleStop();
          }
        }

        // On level change, reset sliders & attempts.
        useEffect(() => {
          const newBandCount = getActiveBandCount(level);
          const oldBandCount = sliders.length;
          
          // If band count has changed, we need to recreate the filters
          if (newBandCount !== oldBandCount) {
            console.log(`Band count changed from ${oldBandCount} to ${newBandCount}, recreating filters`);
            
            // Create a fresh array of sliders for the new band count
            setSliders(new Array(newBandCount).fill(0));
            
            // Recreate all filters if audio context exists
            if (audioContextRef.current) {
              // Clear existing filters first
              filtersRef.current.forEach(filter => {
                try { filter.disconnect(); } catch (e) {}
              });
              
              // Create fresh filters for the new band count
              const newFilters = [];
              for (let i = 0; i < 31; i++) { // Always create 31 filters for maximum flexibility
                const f = audioContextRef.current.createBiquadFilter();
                f.type = "peaking";
                f.frequency.value = 1000; // Default frequency
                f.Q.value = 1;
                f.gain.value = 0;
                newFilters.push(f);
              }
              
              // Replace existing filters with new ones
              filtersRef.current = newFilters;
              
              // Rewire audio chain with new filters
              rewireAudioChain();
              
              // Update the EQ filters with appropriate frequencies for the new band count
              updateEqFilters();
            }
          } else {
            // If no band count change, just update slider array and reset values
            setSliders(new Array(newBandCount).fill(0));
          }
          
          setAttemptsLeft(3);
          setRoundTime(30);
          setFeedback("");
        }, [activeBandCount, level]);

        // Cleanup on unmount
        useEffect(() => {
          return () => {
            if (timerRef.current) clearInterval(timerRef.current);
            if (trackPositionTimerRef.current) clearInterval(trackPositionTimerRef.current);
            if (audioContextRef.current && audioContextRef.current.state !== "closed") {
              audioContextRef.current.close();
            }
            if (crowdAudioRef.current) {
              crowdAudioRef.current.pause();
              crowdAudioRef.current.currentTime = 0;
            }
            if (referenceFlashTimerRef.current) {
              clearInterval(referenceFlashTimerRef.current);
            }
            // Clean up oscillator on unmount
            stopFeedbackOscillator();
          };
        }, []);

        // Check if a slider position is close to the target value (simplified to one test)
        function isCloseToTarget(targetMod, sliderValue) {
          if (!targetMod) return false;
          
          // Special case for feedback elimination mode
          if (feedbackActive && targetMod.index === feedbackSliderIndex) {
            // For feedback mode, we always want to check if we're close to -12dB
            const error = Math.abs(sliderValue - (-12)); // Target is always -12 for feedback
            console.log(`Feedback mode check: slider=${sliderValue}, target=-12, error=${error}`);
            return error <= 2;
          }
          
          // Normal case (regular EQ game)
          const targetVal = -targetMod.gain;
          const error = Math.abs(sliderValue - targetVal);
          // Consider "close" if within 2dB of target (same as 3-star rating)
          console.log(`Checking if close to target: slider=${sliderValue}, target=${targetVal}, error=${error}`);
          return error <= 2;
        }

        // Handle slider change in feedback elimination mode
        function handleSliderChangeFeedback(i, val) {
          if (i === feedbackSliderIndex) {
            // For feedback elimination, need to check if the slider is being moved toward -12dB
            if (val <= -3) { // Only need to move 3dB downwards instead of -10dB
              // Successfully eliminated feedback - stop the oscillator
              stopFeedbackOscillator();
              
              setFeedback("PHEW! FEEDBACK ELIMINATED!");
              const eqPanel = document.querySelector('.eqPanel');
              if (eqPanel) {
                eqPanel.style.background = '#22c55e'; // Flash green
                setTimeout(() => {
                  eqPanel.style.background = '#1e3a8a'; // Reset to normal blue
                }, 1500); // Longer flash - 1.5 seconds
              }
              
              setFeedbackActive(false);
              
              // Award points
              const points = 100;
              setTotalScore(prev => {
                const newScore = prev + points;
                if (newScore > hiScore) setHiScore(newScore);
                return newScore;
              });
              
              // Reset the filter that was causing feedback
              if (filtersRef.current && filtersRef.current[feedbackSliderIndex]) {
                filtersRef.current[feedbackSliderIndex].gain.value = 0;
              }
              
              // Clear sliders and prepare for next round WITHOUT animation
              setTimeout(() => {
                setFeedback("");
                setFeedbackMode(false);
                
                // Reset all sliders to 0 directly
                setSliders(new Array(activeBandCount).fill(0));
                
                // Reset all filters to zero directly
                if (filtersRef.current) {
                  for (let i = 0; i < filtersRef.current.length; i++) {
                    if (filtersRef.current[i]) {
                      filtersRef.current[i].gain.value = 0;
                    }
                  }
                }
                
                // Start a completely fresh round
                startRound();
              }, 1500); // Match the timing with the green flash
              return true;
            }
          } else {
            // Wrong slider moved in feedback mode - lose a life
            // IMMEDIATELY disable all slider interactions to prevent multiple life losses
            setSliderInteractionDisabled(true);
            
            setLives(prev => {
              const newLives = prev - 1;
              
              if (newLives <= 0) {
                // Stop the oscillator on game over
                stopFeedbackOscillator();
                handleGameOver();
                return 0;
              }
              
              // Flash red for incorrect slider
              const eqPanel = document.querySelector('.eqPanel');
              if (eqPanel) {
                eqPanel.style.background = '#ff0000'; // Flash red
                setTimeout(() => {
                  eqPanel.style.background = '#1e3a8a'; // Reset to normal blue
                }, 300);
              }
              
              // Display heckling message
              const randomHeckle = hecklingMessages[Math.floor(Math.random() * hecklingMessages.length)];
              setFeedback(`${randomHeckle} ${newLives} ${newLives > 1 ? "LIVES" : "LIFE"} LEFT`);
              
              // STOP THE MUSIC immediately
              if (audioSourceRef.current) {
                try {
                  audioSourceRef.current.stop();
                } catch (e) {}
              }
              
              // IMMEDIATELY start fading out the feedback oscillator
              stopFeedbackOscillator();
              
              // Set flag to wait for user click
              setFeedbackMode(false);
              setFeedbackActive(false);
              setSliderInteractionDisabled(false);
              
              // Don't auto-start the next round - wait for user action
              return newLives;
            });
            return true;
          }
          
          return false; // No special feedback action taken
        }
        
        // Handle slider change in regular gameplay mode
        function handleSliderChangeRegular(i) {
          if (isPlaying && !feedbackMode) {
            // Set auto-check timer for inactivity
            if (sliderTimeoutRef.current) clearTimeout(sliderTimeoutRef.current);
            sliderTimeoutRef.current = setTimeout(() => {
              if (Date.now() - lastSliderChangeRef.current >= 1500) {
                handleSubmitAttempt();
              }
            }, 1500);
          }
          
          return false; // No immediate action needed
        }

        // Simplified slider change handler
        function handleSliderChange(i, val) {
          // If slider interactions are disabled, ignore all slider movements
          if (sliderInteractionDisabled) return false;
          
          // Update the slider state
          const newSliders = [...sliders];
          newSliders[i] = val;
          setSliders(newSliders);
          
          // Record the timestamp of this change
          lastSliderChangeRef.current = Date.now();
          
          // Either use feedback mode OR regular mode
          if (feedbackActive && !gameOver) {
            return handleSliderChangeFeedback(i, val);
          } else {
            return handleSliderChangeRegular(i);
          }
        }

        // Submission logic - simplified to just check target position
        function handleSubmitAttempt() {
          if (!isPlaying) return;
          clearInterval(timerRef.current);
          timerRef.current = null;

          // Hide any frequency hint if shown
          setShowingFrequencyHint(false);

          // Get the target mod for checking
          const targetMod = targetMods.length > 0 ? targetMods[0] : null;
          if (targetMod) {
            const targetIndex = targetMod.index;
            const sliderVal = sliders[targetIndex] || 0;
            const targetVal = -targetMod.gain;
            
            // Calculate the error (how far from target)
            const error = Math.abs(sliderVal - targetVal);
            
            // Calculate time bonus - starts at 10000 and counts down to 0 over 60 seconds
            const tTaken = Math.min(60, (Date.now() - startTime) / 1000);
            const timeBonus = Math.floor(10000 * (1 - tTaken / 60));
            
            // Calculate proximity bonus based on how close to target
            let proximityBonus = 0;
            if (error <= 1) proximityBonus = 3000;
            else if (error <= 3) proximityBonus = 2000;
            else if (error <= 6) proximityBonus = 1000;
            else if (error <= 9) proximityBonus = 500;
            
            // Determine if the slider is in the right direction
            const correctDirection = (targetVal > 0 && sliderVal > 0) || (targetVal < 0 && sliderVal < 0);
            
            // Determine star rating based on remaining attempts
            // Since we're checking after each guess now, we need to adjust
            const starRating = attemptsLeft;
            
            // Success condition - slider is in right direction and close enough
            if (Math.abs(sliderVal) > 0.1 && (correctDirection || error <= 9)) {
              // Calculate final score: time bonus + (proximity bonus * star rating)
              const score = timeBonus + (proximityBonus * starRating);
              
              setRoundScore(score);
              setFeedback(`YEP +${score} ${"".repeat(starRating)}`);
              setFeedbackMode(true);
              
              animateSlidersThenReset(() => {
                setTotalScore(prev => {
                  const newTotal = prev + score;
                  if (newTotal > hiScore) setHiScore(newTotal);
                  return newTotal;
                });
                setIsPlaying(false);
                setFeedback("");
                setFeedbackMode(false);
                handleLevelChange(level + 1);
                startRound();
              });
              return;
            }
          }
          
          // No correct match found - wrong attempt
          setFeedback("NOPE");
          
          // Reset sliders to neutral position after wrong guess
          setSliders(new Array(activeBandCount).fill(0));
          
          // Also reset all filter values to neutral
          if (filtersRef.current) {
            for (let i = 0; i < filtersRef.current.length; i++) {
              if (filtersRef.current[i]) {
                filtersRef.current[i].gain.value = targetMods.find(m => m.index === i)?.gain || 0;
              }
            }
          }
          
          if (attemptsLeft > 1) {
            // If this is the second wrong attempt, show a hint
            if (attemptsLeft === 2) {
              showFrequencyHint();
            }
            
            setAttemptsLeft(prev => prev - 1);
            setTimeout(() => {
              setFeedback(""); 
              
              // Restart the timer after showing feedback
              if (isPlaying) {
                let timeLeft = roundTime;
                timerRef.current = setInterval(() => {
                  timeLeft--;
                  setRoundTime(timeLeft);
                  
                  if (timeLeft <= 0) {
                    clearInterval(timerRef.current);
                    timerRef.current = null;
                    
                    // Time's up - lose a life if still playing
                    if (isPlaying) {
                      // Stop any feedback oscillator that might be active
                      stopFeedbackOscillator();
                      
                      setLives(prevLives => {
                        const newLives = prevLives - 1;
                        
                        if (newLives <= 0) {
                          handleGameOver();
                          return 0;
                        }
                        
                        // Display random heckling message
                        const randomHeckle = hecklingMessages[Math.floor(Math.random() * hecklingMessages.length)];
                        setFeedback(`${randomHeckle} ${newLives} ${newLives > 1 ? "LIVES" : "LIFE"} LEFT`);
                        
                        // Reset game state
                        setIsPlaying(false);
                        
                        return newLives;
                      });
                    }
                  }
                }, 1000);
              }
            }, 1500);
          } else {
            // On third attempt, trigger feedback mode instead of hint system
            triggerFeedbackMode();
          }
        }

        // Show frequency hint with descriptive text for the target frequency
        function showFrequencyHint() {
          if (targetMods.length > 0) {
            const targetMod = targetMods[0];
            const targetFreq = freqArray[targetMod.index].value;
            const descriptor = freqDescriptors[targetFreq] || "UNKNOWN";
            
            // Determine if we need more or less of the frequency based on gain
            // FIXED: When gain is positive (boosting), we need to turn DOWN (TOO MUCH)
            // When gain is negative (cutting), we need to turn UP (NOT ENOUGH)
            const direction = targetMod.gain > 0 ? "TOO MUCH" : "NOT ENOUGH";
            setFrequencyHintText(`${direction} ${descriptor}`);
            setShowingFrequencyHint(true);
            
            // Hide the hint after 3 seconds
            setTimeout(() => {
              setShowingFrequencyHint(false);
            }, 3000);
          }
        }

        // Update track position when playing - Fixed to prevent looping
        useEffect(() => {
          if (audioPlayerState === 'playing') {
            // Clear any existing timer to prevent multiple timers
            if (trackPositionTimerRef.current) {
              clearInterval(trackPositionTimerRef.current);
              trackPositionTimerRef.current = null;
            }
            
            // Start a timer to update position every 200ms
            trackPositionTimerRef.current = setInterval(() => {
              if (audioSourceRef.current && !isUpdatingPosition && audioContextRef.current && trackDuration > 0) {
                const elapsed = audioContextRef.current.currentTime - audioSourceRef.current.startTime;
                
                // Simple check - if elapsed time exceeds duration, advance to next track
                if (elapsed >= trackDuration) {
                  // Clear timer immediately to prevent multiple triggers
                  clearInterval(trackPositionTimerRef.current);
                  trackPositionTimerRef.current = null;
                  
                  console.log('Track ended naturally, advancing to next track');
                  
                  // Use a timeout to ensure this happens outside the current execution context
                  setTimeout(() => {
                    handleNextTrack();
                  }, 100);
                  
                  return;
                }
                
                setTrackPosition(elapsed);
              }
            }, 200);
            
            return () => {
              if (trackPositionTimerRef.current) {
                clearInterval(trackPositionTimerRef.current);
                trackPositionTimerRef.current = null;
              }
            };
          }
        }, [audioPlayerState, isUpdatingPosition, trackDuration]);

        // Build EQ chain.
        function rewireAudioChain() {
          if (!audioContextRef.current || !audioSourceRef.current || !gainNodeRef.current || filtersRef.current.length === 0)
            return;
          const context = audioContextRef.current;
          const source = audioSourceRef.current;
          const gainNode = gainNodeRef.current;
          try { source.disconnect(); } catch(e){}
          filtersRef.current.forEach(f => { try { f.disconnect(); } catch(e){} });
          source.connect(filtersRef.current[0]);
          for (let i = 0; i < filtersRef.current.length - 1; i++) {
            filtersRef.current[i].connect(filtersRef.current[i+1]);
          }
          filtersRef.current[filtersRef.current.length - 1].connect(gainNode);
          // Dry path.
          gainNode.connect(context.destination);
          // Wet (echo) path.
          if (delayNodeRef.current && feedbackGainRef.current && wetGainRef.current) {
            gainNode.connect(delayNodeRef.current);
            delayNodeRef.current.connect(feedbackGainRef.current);
            feedbackGainRef.current.connect(delayNodeRef.current);
            delayNodeRef.current.connect(wetGainRef.current);
            wetGainRef.current.connect(context.destination);
          }
        }

        // Update EQ filters - Refactored to use centralized filter update
        function updateEqFilters() {
          if (!filtersRef.current || filtersRef.current.length < activeBandCount) return;
          
          // First set appropriate frequencies and Q values
          for (let i = 0; i < activeBandCount; i++) {
            const filter = filtersRef.current[i];
            if (filter) {
              filter.frequency.value = freqArray[i].value;
              filter.Q.value = 1;
            }
          }
          
          // Then calculate and apply all gain values in one operation
          const gainValues = new Array(filtersRef.current.length).fill(0);
          
          // Apply target mods first
          targetMods.forEach(mod => {
            if (mod.index >= 0 && mod.index < gainValues.length) {
              gainValues[mod.index] = mod.gain;
            }
          });
          
          // Then add slider values
          sliders.forEach((val, i) => {
            if (i < gainValues.length) {
              gainValues[i] += val;
            }
          });
          
          // Apply all filter gains at once
          applyFilterGains(gainValues);
        }
        useEffect(() => { updateEqFilters(); }, [sliders, targetMods]);

        // Handle multiple file selection
        async function handleFilesChange(e) {
          const files = Array.from(e.target.files);
          if (files && files.length > 0) {
            setAudioFiles(files);
            
            // Initialize context and decode all files in the background
            let context = audioContextRef.current;
            if (!context || context.state === "closed") {
              context = new AudioContext();
              audioContextRef.current = context;
            }
            
            // Decode all files and store their audio buffers
            const buffers = [];
            for (let i = 0; i < files.length; i++) {
              try {
                const arrayBuffer = await files[i].arrayBuffer();
                const audioBuffer = await context.decodeAudioData(arrayBuffer);
                buffers.push(audioBuffer);
              } catch (err) {
                console.error(`Error decoding file ${files[i].name}:`, err);
              }
            }
            
            audioBuffersRef.current = buffers;
            setCurrentTrackIndex(0);
            setTrackPosition(0);
            
            // Setup audio but don't play yet - user should press play
            await loadCurrentTrack(0, false);
          }
        }

        // Create echo effect using DelayNode.
        function createEchoEffect(context) {
          const delay = context.createDelay();
          delay.delayTime.value = 0.08; // longer delay
          const fb = context.createGain();
          fb.gain.value = 0.6; // feedback gain remains 0.6
          const wet = context.createGain();
          wet.gain.value = roomAmbiance; // controlled by slider (0 to 0.75 now)
          delay.connect(fb);
          fb.connect(delay);
          delay.connect(wet);
          delayNodeRef.current = delay;
          feedbackGainRef.current = fb;
          wetGainRef.current = wet;
        }

        // Load and play the current track - Modified to ensure proper playback after track changes
        async function loadCurrentTrack(index = null, autoplay = true) {
          // If index is provided, update the current track index
          if (index !== null) {
            setCurrentTrackIndex(index);
          } else {
            index = currentTrackIndex;
          }
          
          // Make sure we have valid files and buffers
          if (!audioBuffersRef.current.length || index >= audioBuffersRef.current.length) {
            return;
          }
          
          // Get the buffer for this track
          const audioBuffer = audioBuffersRef.current[index];
          if (!audioBuffer) return;
          
          // Create context if needed
          let context = audioContextRef.current;
          if (!context || context.state === "closed") {
            context = new AudioContext();
            audioContextRef.current = context;
          } else if (context.state === "suspended") {
            await context.resume();
          }
          
          // Master gain
          if (!gainNodeRef.current) {
            const gainNode = context.createGain();
            gainNode.gain.value = (masterVolume / 10) * 0.79;
            gainNodeRef.current = gainNode;
          }
          
          // Create echo effect if needed
          if (!delayNodeRef.current) {
            createEchoEffect(context);
          }
          
          // Stop current playback if any
          if (audioSourceRef.current) {
            try {
              audioSourceRef.current.stop();
            } catch (e) {}
            try {
              audioSourceRef.current.disconnect();
            } catch (e) {}
          }
          
          // CRITICAL FIX: Always set track position to 0 when changing tracks
          // This ensures tracks start from the beginning
          if (index !== currentTrackIndex) {
            setTrackPosition(0);
          }
          
          // Create new source node
          const source = context.createBufferSource();
          source.buffer = audioBuffer;
          source.loop = false; // We'll handle looping manually to allow for track changes
          
          // Store start time for position tracking
          source.startTime = context.currentTime;
          
          audioSourceRef.current = source;
          setTrackDuration(audioBuffer.duration);
          
          // Build filter nodes if needed
          if (filtersRef.current.length === 0) {
            const newFilters = [];
            for (let i = 0; i < 31; i++) {
              const f = context.createBiquadFilter();
              f.type = "peaking";
              f.frequency.value = 1000;
              f.Q.value = 1;
              f.gain.value = 0;
              newFilters.push(f);
            }
            filtersRef.current = newFilters;
          }
          
          // Connect audio chain
          rewireAudioChain();
          
          // CRITICAL FIX: When switching tracks, always use position 0 instead of trackPosition
          const startPosition = (index !== currentTrackIndex) ? 0 : trackPosition;
          
          // Start playback if we should autoplay
          if (autoplay) {
            // IMPORTANT: Set the audioPlayerState to 'playing' BEFORE starting audio
            setAudioPlayerState('playing');
            context.resume();
            source.start(0, startPosition);
            
            // Start crowd ambiance if needed
            if (crowdAudioRef.current) {
              crowdAudioRef.current.volume = crowdVolume;
              if (crowdAudioRef.current.readyState > 0) {
                try {
                  crowdAudioRef.current.play();
                } catch (e) {
                  console.error("Could not play crowd audio", e);
                }
              }
            }
          }
          
          updateEqFilters();
          
          // Log to confirm track is playing
          console.log(`Track ${index} loaded with position ${startPosition}, autoplay=${autoplay}`);
        }

        // Handle when a track ends and should advance to the next
        function handleTrackEnded() {
          console.log("Track ended detected");
          
          // Stop any active timers
          if (trackPositionTimerRef.current) {
            clearInterval(trackPositionTimerRef.current);
            trackPositionTimerRef.current = null;
          }
          
          if (timerRef.current) {
            clearInterval(timerRef.current);
            timerRef.current = null;
          }

          // Simple solution - just use the next track handler
          // that already has all the cleanup logic we need
          handleNextTrack();
        }

        // Modified Play button handler - ONLY plays audio without starting the game
        function handlePlay() {
          // No audio loaded
          if (audioBuffersRef.current.length === 0) return;
            
          if (audioPlayerState === 'paused') {
            // Resume playback from current position
            if (audioContextRef.current && audioSourceRef.current) {
              audioContextRef.current.resume();
              // Need to create a new source node since the old one can't be restarted
              const newSource = audioContextRef.current.createBufferSource();
              newSource.buffer = audioSourceRef.current.buffer;
              newSource.loop = false;
              
              // Set up onended handler
              newSource.onended = () => {
                handleTrackEnded();
              };
              
              newSource.startTime = audioContextRef.current.currentTime - trackPosition;
              
              // Replace the old source
              try { audioSourceRef.current.disconnect(); } catch(e) {}
              audioSourceRef.current = newSource;
              
              // Connect and start
              rewireAudioChain();
              newSource.start(0, trackPosition);
              
              setAudioPlayerState('playing');
              
              // Don't start the game automatically anymore
            }
          } else if (audioPlayerState === 'stopped') {
            // Start from the beginning
            loadCurrentTrack(currentTrackIndex, true);
            setAudioPlayerState('playing');
            
            // Don't start the game automatically anymore
          }
        }

        // Pause button handler - modified to toggle between pause and play
        function handlePause() {
          if (audioPlayerState === 'playing' && audioContextRef.current && audioSourceRef.current) {
            // Calculate current position before stopping
            const currentTime = (audioContextRef.current.currentTime - audioSourceRef.current.startTime) % trackDuration;
            setTrackPosition(currentTime);
            
            // Stop playback
            audioSourceRef.current.stop();
            audioContextRef.current.suspend();
            
            setAudioPlayerState('paused');
            
            // Also pause crowd noise
            if (crowdAudioRef.current && !crowdAudioRef.current.paused) {
              crowdAudioRef.current.pause();
            }
          } else if (audioPlayerState === 'paused') {
            // Resume playback (same as handlePlay for paused state)
            if (audioContextRef.current && audioSourceRef.current) {
              audioContextRef.current.resume();
              // Need to create a new source node since the old one can't be restarted
              const newSource = audioContextRef.current.createBufferSource();
              newSource.buffer = audioSourceRef.current.buffer;
              newSource.loop = false;
              
              // Set up onended handler
              newSource.onended = () => {
                handleTrackEnded();
              };
              
              newSource.startTime = audioContextRef.current.currentTime - trackPosition;
              
              // Replace the old source
              try { audioSourceRef.current.disconnect(); } catch(e) {}
              audioSourceRef.current = newSource;
              
              // Connect and start
              rewireAudioChain();
              newSource.start(0, trackPosition);
              
              setAudioPlayerState('playing');
              
              // Resume crowd noise if it was playing before
              if (crowdAudioRef.current && crowdVolume > 0 && crowdAudioRef.current.readyState >= 2) {
                try {
                  crowdAudioRef.current.play()
                    .catch(e => console.error("Error resuming crowd audio:", e));
                } catch (e) {
                  console.error("Error playing crowd audio:", e);
                }
              }
            }
          }
        }

        // Stop button handler
        function handleStop() {
          if (audioSourceRef.current) {
            try {
              audioSourceRef.current.stop();
            } catch (e) {}
            
            setTrackPosition(0);
            setAudioPlayerState('stopped');
            
            // Also stop game
            setIsPlaying(false);
            
            // Stop crowd noise
            if (crowdAudioRef.current && !crowdAudioRef.current.paused) {
              crowdAudioRef.current.pause();
              crowdAudioRef.current.currentTime = 0;
            }
          }
        }

        // Next track button handler - ensure crowd volume persists
        function handleNextTrack() {
          if (audioBuffersRef.current.length <= 1) return;
          
          // Prevent multiple rapid calls which cause glitching
          if (isUpdatingPosition) return;
          
          // Set a flag to prevent concurrent operations
          setIsUpdatingPosition(true);
          
          // Calculate next index - loop back to beginning when reaching the end
          const nextIndex = (currentTrackIndex + 1) >= audioBuffersRef.current.length ? 0 : currentTrackIndex + 1;
          const wasPlaying = audioPlayerState === 'playing';
          
          // Explicitly capture the current crowd volume from state before any async operations
          const currentCrowdVolumeValue = crowdVolume;
          console.log("Next track - preserving crowd volume:", currentCrowdVolumeValue);
          
          // Stop all audio and remove all timers
          if (trackPositionTimerRef.current) {
            clearInterval(trackPositionTimerRef.current);
            trackPositionTimerRef.current = null;
          }
          
          // Always reset position to 0 for next track
          setTrackPosition(0);
          
          // Reset all sliders to neutral position
          setSliders(new Array(activeBandCount).fill(0));
          
          // Completely destroy the audio context and recreate it
          if (audioContextRef.current) {
            // First disconnect and stop any existing audio
            if (audioSourceRef.current) {
              try {
                audioSourceRef.current.onended = null; // Remove the event handler
                audioSourceRef.current.stop();
                audioSourceRef.current.disconnect();
              } catch(e) {}
              audioSourceRef.current = null;
            }
            
            // Need to update track info before context is closed
            setCurrentTrackIndex(nextIndex);

            // Create a small delay to ensure complete cleanup
            setTimeout(() => {
              // Create a brand new audio context
              const newContext = new AudioContext();
              audioContextRef.current = newContext;
              
              // Reset other audio components
              gainNodeRef.current = null;
              filtersRef.current = [];
              delayNodeRef.current = null;
              feedbackGainRef.current = null;
              wetGainRef.current = null;
              
              // Start fresh with the new track - ALWAYS from position 0
              loadCurrentTrack(nextIndex, wasPlaying);
              
              // Make sure crowd noise keeps playing with proper volume
              if (crowdAudioRef.current) {
                // Always set the volume to the captured state value, regardless of playback state
                crowdAudioRef.current.volume = currentCrowdVolumeValue;
                console.log("Restored crowd volume to:", currentCrowdVolumeValue);
                
                // Start playing if needed and volume > 0
                if (currentCrowdVolumeValue > 0 && crowdAudioRef.current.paused && crowdAudioRef.current.readyState >= 2) {
                  try {
                    crowdAudioRef.current.play()
                      .catch(e => console.error("Error restarting crowd audio:", e));
                  } catch (e) {
                    console.error("Error playing crowd audio:", e);
                  }
                }
              }
              
              // Reset the flag when done
              setIsUpdatingPosition(false);
            }, 100);
          } else {
            // If no context exists yet, just load the track
            setCurrentTrackIndex(nextIndex);
            // ALWAYS start from position 0
            loadCurrentTrack(nextIndex, wasPlaying);
            setIsUpdatingPosition(false);
          }
        }
        
        // Previous track button handler
        function handlePrevTrack() {
          if (audioBuffersRef.current.length <= 1) return;
          
          // Prevent multiple rapid calls which cause glitching
          if (isUpdatingPosition) return;
          
          // Set a flag to prevent concurrent operations
          setIsUpdatingPosition(true);
          
          // Calculate the previous track index with wrap-around
          const targetIndex = (currentTrackIndex - 1 + audioBuffersRef.current.length) % audioBuffersRef.current.length;
          
          // Always set position to 0 for track changes
          setTrackPosition(0);
          
          // Reset all sliders to neutral position
          setSliders(new Array(activeBandCount).fill(0));
          
          // Store if we were playing to maintain playback state
          const wasPlaying = audioPlayerState === 'playing' || audioPlayerState === 'paused';
          
          // Explicitly capture the current crowd volume from state before any async operations
          const currentCrowdVolumeValue = crowdVolume;
          console.log("Previous track - preserving crowd volume:", currentCrowdVolumeValue);
          
          // Completely destroy the audio context and recreate it
          if (audioContextRef.current) {
            // First disconnect and stop any existing audio
            if (audioSourceRef.current) {
              try {
                audioSourceRef.current.onended = null; // Remove the event handler
                audioSourceRef.current.stop();
                audioSourceRef.current.disconnect();
              } catch(e) {}
              audioSourceRef.current = null;
            }
            
            // Update track index
            setCurrentTrackIndex(targetIndex);
            
            // Create a small delay to ensure complete cleanup
            setTimeout(() => {
              // Create a brand new audio context
              const newContext = new AudioContext();
              audioContextRef.current = newContext;
              
              // Reset other audio components
              gainNodeRef.current = null;
              filtersRef.current = [];
              delayNodeRef.current = null;
              feedbackGainRef.current = null;
              wetGainRef.current = null;
              
              // Start fresh with the new track - ALWAYS from position 0
              loadCurrentTrack(targetIndex, wasPlaying);
              
              // Make sure crowd noise keeps playing with proper volume
              if (crowdAudioRef.current) {
                // Always set the volume to the captured state value, regardless of playback state
                crowdAudioRef.current.volume = currentCrowdVolumeValue;
                console.log("Restored crowd volume to:", currentCrowdVolumeValue);
                
                // Start playing if needed and volume > 0
                if (currentCrowdVolumeValue > 0 && crowdAudioRef.current.paused && crowdAudioRef.current.readyState >= 2) {
                  try {
                    crowdAudioRef.current.play()
                      .catch(e => console.error("Error restarting crowd audio:", e));
                  } catch (e) {
                    console.error("Error playing crowd audio:", e);
                  }
                }
              }
              
              // Reset the flag when done
              setIsUpdatingPosition(false);
            }, 100);
          } else {
            // If no context exists yet, just load the track
            setCurrentTrackIndex(targetIndex);
            // ALWAYS start from position 0
            loadCurrentTrack(targetIndex, wasPlaying);
            setIsUpdatingPosition(false);
          }
        }

        // Shuffle tracks
        function shuffleTracks() {
          if (audioBuffersRef.current.length <= 1) return;
          
          // Create a copy of the current buffers and files
          const buffersCopy = [...audioBuffersRef.current];
          const filesCopy = [...audioFiles];
          
          // Fisher-Yates shuffle algorithm
          for (let i = buffersCopy.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            // Swap buffers
            [buffersCopy[i], buffersCopy[j]] = [buffersCopy[j], buffersCopy[i]];
            // Swap files
            [filesCopy[i], filesCopy[j]] = [filesCopy[j], filesCopy[i]];
          }
          
          // Update state and refs
          audioBuffersRef.current = buffersCopy;
          setAudioFiles(filesCopy);
          setCurrentTrackIndex(0);
          setTrackPosition(0);
          
          // Load the first track after shuffling
          loadCurrentTrack(0, audioPlayerState === 'playing');
        }

        // Format seconds to MM:SS
        function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Track position slider change - Improved to prevent glitches
        function handlePositionChange(e) {
          if (audioBuffersRef.current.length === 0) return;
          
          // Set flag immediately to prevent position updates during this operation
          setIsUpdatingPosition(true);
          const newPosition = parseFloat(e.target.value);
          setTrackPosition(newPosition);
          
          // If playing, restart with new position
          if (audioPlayerState === 'playing') {
            if (audioSourceRef.current && audioContextRef.current) {
              try {
                // Stop current playback completely and remove event handlers
                audioSourceRef.current.onended = null;
                audioSourceRef.current.stop();
                audioSourceRef.current.disconnect();
              } catch(e) {}
              
              // Create new source node with the same buffer
              const currentBuffer = audioSourceRef.current.buffer;
              
              // Create new source node
              const newSource = audioContextRef.current.createBufferSource();
              newSource.buffer = currentBuffer;
              newSource.loop = false;
              
              // Set new start time for accurate position tracking
              newSource.startTime = audioContextRef.current.currentTime - newPosition;
              
              // Replace the old source
              audioSourceRef.current = newSource;
              
              // Connect and start
              rewireAudioChain();
              newSource.start(0, newPosition);
            }
          }
          
          // Reset the flag after a delay
          setTimeout(() => setIsUpdatingPosition(false), 200);
        }

        // Play specific track from playlist
        function playTrack(index) {
          if (index === currentTrackIndex && audioPlayerState === 'playing') {
            return; // Already playing this track
          }
          
          const wasPlaying = audioPlayerState === 'playing' || audioPlayerState === 'paused';
          loadCurrentTrack(index, wasPlaying);
          
          if (wasPlaying) {
            setAudioPlayerState('playing');
          }
          
          // Also start game if needed
          if (!isPlaying && wasPlaying) {
            startRound();
          }
        }

        // Generate random EQ mod with improved band selection after level changes
        function generateMods() {
          console.log(`Generating mods for level ${level} with ${activeBandCount} frequency bands`);
          
          // Make a fresh array of available indices based on CURRENT frequency array
          let availableIndices = [];
          
          if (lofiMode) {
            // In lo-fi mode, only use bands between 250Hz and 10kHz
            for (let i = 0; i < activeBandCount; i++) {
              if (freqArray[i].value >= 250 && freqArray[i].value <= 10000) {
                availableIndices.push(i);
              }
            }
          } else {
            // Normal mode - use all bands
            for (let i = 0; i < activeBandCount; i++) {
              availableIndices.push(i);
            }
          }
          
          // If we have no available indices due to lo-fi mode restrictions, fallback
          if (availableIndices.length === 0) {
            // Find a middle band that's safe
            for (let i = 0; i < activeBandCount; i++) {
              if (freqArray[i].value >= 250 && freqArray[i].value <= 10000) {
                availableIndices.push(i);
                break;
              }
            }
            if (availableIndices.length === 0) {
              // Ultimate fallback - middle index
              availableIndices.push(Math.floor(activeBandCount / 2));
            }
          }
          
          // Identify new bands added in this level
          const prevLevelBandCount = level <= 5 ? 3 :
                                    level <= 10 ? 5 :
                                    level <= 15 ? 10 :
                                    level <= 20 ? 13 :
                                    level <= 25 ? 16 :
                                    level <= 30 ? 19 :
                                    level <= 35 ? 22 :
                                    level <= 40 ? 25 :
                                    level <= 45 ? 28 : 31;
          
          const newBands = [];
          if (prevLevelBandCount < activeBandCount) {
            for (let i = 0; i < activeBandCount; i++) {
              // Only consider bands from the available indices that are new
              if (availableIndices.includes(i) && i >= prevLevelBandCount) {
                newBands.push(i);
              }
            }
          }
          
          let chosen;
          
          // Prioritize new bands that haven't been tested yet
          if (newBands.length > 0 && Math.random() < 0.7) { // 70% chance to pick from new bands
            chosen = newBands[Math.floor(Math.random() * newBands.length)];
          } else {
            // Sort available indices by how recently they were used
            availableIndices.sort((a, b) => {
              const aLastUsed = bandSelectionHistory.lastIndexOf(a);
              const bLastUsed = bandSelectionHistory.lastIndexOf(b);
              
              // Bands that have never been used go first
              if (aLastUsed === -1) return -1;
              if (bLastUsed === -1) return 1;
              
              // Otherwise sort by least recently used
              return aLastUsed - bLastUsed;
            });
            
            // Pick from top 40% of least recently used bands
            const candidateCount = Math.max(1, Math.floor(availableIndices.length * 0.4));
            chosen = availableIndices[Math.floor(Math.random() * candidateCount)];
          }
          
          // Update the history
          setBandSelectionHistory(prev => {
            const newHistory = [...prev, chosen];
            // Keep the last 10 entries only to limit memory usage
            if (newHistory.length > 10) newHistory.splice(0, newHistory.length - 10);
            return newHistory;
          });
          
          // Get EQ intensity based on difficulty
          const modVal = difficultySettings[difficulty].min + 
            Math.random() * (difficultySettings[difficulty].max - difficultySettings[difficulty].min);
          
          // Determine if this should be a cut or boost based on frequency
          let gainVal;
          if (chosen < freqArray.length && freqArray[chosen].value < 100) {
            // For frequencies below 100, always use cuts (negative gain)
            gainVal = -modVal;
          } else {
            // For all other frequencies, randomly choose cut or boost
            gainVal = Math.random() > 0.5 ? modVal : -modVal;
          }
          
          // Create a new target mod with consistent index
          const newTargetMods = [{ index: chosen, gain: gainVal }];
          
          // Log detailed info to help debug
          console.log(`Generated target mod: band ${chosen} (${freqArray[chosen].label}), gain ${gainVal.toFixed(2)}dB`);
          console.log(`Current frequency array: ${JSON.stringify(freqArray.map(f => f.label))}`);
          
          return newTargetMods;
        }

        // Create a random feedback issue on a slider in the 250-10k range
        // Updated to ensure it stays on the originally targeted band when possible
        function generateFeedbackSlider() {
          // First, check if we can use the existing target mod
          if (targetMods.length > 0) {
            const existingMod = targetMods[0];
            
            // Check if the existing target band is within the 250-10k range
            if (existingMod && existingMod.index >= 0 && 
                existingMod.index < freqArray.length &&
                freqArray[existingMod.index].value >= 250 && 
                freqArray[existingMod.index].value <= 10000) {
              
              console.log(`Using original target band for feedback: ${freqArray[existingMod.index].label}`);
              setFeedbackSliderIndex(existingMod.index);
              return existingMod.index;
            }
          }
          
          // If no suitable existing target, find bands that are in the 250-10k range
          const eligibleSliders = [];
          for (let i = 0; i < freqArray.length; i++) {
            const freq = freqArray[i].value;
            if (freq >= 250 && freq <= 10000) {
              eligibleSliders.push(i);
            }
          }
          
          // If we have eligible sliders, pick one randomly
          if (eligibleSliders.length > 0) {
            const randomSliderIndex = eligibleSliders[Math.floor(Math.random() * eligibleSliders.length)];
            setFeedbackSliderIndex(randomSliderIndex);
            console.log(`Selected random feedback slider: ${freqArray[randomSliderIndex].label}`);
            return randomSliderIndex;
          }
          
          // Fallback to middle slider if no eligible sliders in frequency range
          const middleIndex = Math.floor(freqArray.length / 2);
          setFeedbackSliderIndex(middleIndex);
          return middleIndex;
        }

        // Handle level change with proper re-initialization
        function handleLevelChange(newLevel) {
          console.log(`Level changing from ${level} to ${newLevel}`);
          
          // Stop any active game play
          setIsPlaying(false);
          setRoundStarted(false);
          setFeedback("");
          setCountdownActive(false);
          setFeedbackMode(false);
          
          // Reset all filters to zero
          if (filtersRef.current) {
            filtersRef.current.forEach(filter => {
              if (filter) {
                filter.gain.value = 0;
              }
            });
          }
          
          // Clear all timers
          if (timerRef.current) clearInterval(timerRef.current);
          if (sliderTimeoutRef.current) clearTimeout(sliderTimeoutRef.current);
          
          // Update level state
          setLevel(newLevel);
          
          // Wait for level state and frequency arrays to update 
          // before doing anything that depends on the new level
          setTimeout(() => {
            // Create a fresh array of sliders for the new level's band count
            const newBandCount = getActiveBandCount(newLevel);
            setSliders(new Array(newBandCount).fill(0));
            setAttemptsLeft(3);
            setRoundTime(30);
            
            // Clear target mods
            setTargetMods([]);
            
            console.log(`Ready for level ${newLevel} with ${newBandCount} bands`);
            
            // Don't auto-start the next round - allow user to click Start Round
          }, 300);
        }

        // Modified startRound function to properly handle band count changes
        async function startRound() {
          if (audioBuffersRef.current.length === 0) return; // Need audio files first
          if (audioPlayerState !== 'playing') return; // Audio must be playing first
          
          // Reset the game state and clear any existing EQ modifications
          setRoundStarted(true);
          setSliders(new Array(activeBandCount).fill(0));
          setAttemptsLeft(3);
          setRoundTime(30);
          setFeedback("");
          
          // Clear target mods and reset all filter values to neutral
          setTargetMods([]);
          if (filtersRef.current) {
            for (let i = 0; i < filtersRef.current.length; i++) {
              if (filtersRef.current[i]) {
                filtersRef.current[i].gain.value = 0;
              }
            }
          }
          
          setRoundScore(null);
          
          // Use countdown for all levels
          setCountdownActive(true);
          const steps = [
            { text: "1", duration: 500 },
            { text: "2", duration: 500 },
            { text: "1", duration: 250 },
            { text: "2", duration: 250 },
            { text: "3", duration: 250 },
            { text: "4", duration: 250 }
          ];
          let idx = 0;
          function runStep() {
            if (idx >= steps.length) {
              setCountdownActive(false);
              // ONLY apply EQ changes AFTER countdown completes
              const mods = generateMods(); // This will generate mods appropriate for current activeBandCount
              setTargetMods(mods);
              
              // Ensure the mods are correctly applied to the current EQ configuration
              mods.forEach(m => {
                if (filtersRef.current[m.index]) {
                  // Console log to verify the correct band is being modified
                  console.log(`Setting band ${m.index} (${freqArray[m.index].label}) to ${m.gain.toFixed(2)}dB`);
                  filtersRef.current[m.index].gain.value = m.gain;
                }
              });
              
              setStartTime(Date.now());
              setIsPlaying(true);
              
              // Start 30 second timer
              if (timerRef.current) {
                clearInterval(timerRef.current);
              }
              
              let timeLeft = 30;
              setRoundTime(timeLeft);
              
              timerRef.current = setInterval(() => {
                timeLeft--;
                setRoundTime(timeLeft);
                
                if (timeLeft <= 0) {
                  clearInterval(timerRef.current);
                  timerRef.current = null;
                  
                  // Time's up - lose a life if still playing
                  if (isPlaying) {
                    // Stop any feedback oscillator that might be active
                    stopFeedbackOscillator();
                    
                    setLives(prevLives => {
                      const newLives = prevLives - 1;
                      
                      if (newLives <= 0) {
                        handleGameOver();
                        return 0;
                      }
                      
                      // Display random heckling message
                      const randomHeckle = hecklingMessages[Math.floor(Math.random() * hecklingMessages.length)];
                      setFeedback(`${randomHeckle} ${newLives} ${newLives > 1 ? "LIVES" : "LIFE"} LEFT`);
                      
                      // Reset game state
                      setIsPlaying(false);
                      
                      return newLives;
                    });
                  }
                }
              }, 1000);
              
              // Set crowd volume
              if (crowdAudioRef.current) {
                crowdAudioRef.current.volume = crowdVolume;
                if (crowdAudioRef.current.readyState > 0) {
                  crowdAudioRef.current.play();
                }
              }
              return;
            }
            setCountdownText(steps[idx].text);
            setTimeout(() => { idx++; runStep(); }, steps[idx].duration);
          }
          runStep();
        }

        // Animate sliders to target positions over 2 seconds, then reset.
        function animateSlidersThenReset(onComplete) {
          const initial = sliders.slice();
          const target = new Array(activeBandCount).fill(0);
          targetMods.forEach(m => { target[m.index] = -m.gain; });
          const startTimeAnim = performance.now();
          const duration = 2000;
          let animationFrameId; // Store animation ID so it can be cancelled
          
          function step(now) {
            const progress = Math.min((now - startTimeAnim) / duration, 1);
            const newVals = initial.map((v, i) => v + (target[i] - v) * progress);
            setSliders(newVals);
            
            // Update filter values with animation
            newVals.forEach((v, i) => {
              const m = targetMods.find(x => x.index === i);
              const modVal = m ? m.gain : 0;
              if (filtersRef.current[i]) {
                filtersRef.current[i].gain.value = modVal + v;
              }
            });
            
            // Continue animation or complete it
            if (progress < 1) {
              animationFrameId = requestAnimationFrame(step);
            } 
            else {
              // Reset ALL sliders to neutral after animation completes
              const resetSliders = new Array(activeBandCount).fill(0);
              setSliders(resetSliders);
              
              // Reset all filter values to neutral (or without the EQ changes)
              // This ensures the filters don't have lingering values
              if (filtersRef.current) {
                for (let i = 0; i < filtersRef.current.length; i++) {
                  if (filtersRef.current[i]) {
                    filtersRef.current[i].gain.value = 0;
                  }
                }
              }
              
              // If onComplete callback exists, call it
              if (onComplete) {
                setTimeout(() => {
                  onComplete();
                }, 50); // Small delay to ensure state is updated
              }
            }
          }
          
          // Start the animation
          animationFrameId = requestAnimationFrame(step);
          
          // Return a cleanup function to cancel animation if needed
          return () => {
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
            }
          };
        }

        function handleSubmit() {
          handleSubmitAttempt();
        }

        async function handleNextButton() {
          if (!isPlaying) await startRound();
          else handleSubmit();
        }

        // Keyboard shortcut for "X" to check
        useEffect(() => {
          function onKeyDown(e) {
            if ((e.key === 'x' || e.key === 'X') && isPlaying) {
              handleSubmitAttempt();
            }
            if (e.ctrlKey && e.altKey && (e.key === 'd' || e.key === 'D')) {
              setDebugMode(prev => !prev);
            }
          }
          window.addEventListener('keydown', onKeyDown);
          return () => window.removeEventListener('keydown', onKeyDown);
        }, [isPlaying]);

        useEffect(() => {
          // No timer needed as per requirements - level only changes on success or failure
          if (timerRef.current) {
            clearInterval(timerRef.current);
            timerRef.current = null;
          }
          return () => {
            if (timerRef.current) clearInterval(timerRef.current);
          };
        }, [isPlaying, attemptsLeft]);

        // Volume slider change.
        function handleVolumeChange(e) {
          const vol = parseFloat(e.target.value);
          setMasterVolume(vol);
          if (gainNodeRef.current) {
            gainNodeRef.current.gain.value = (vol / 10) * 0.79;
          }
        }

        // Room Ambiance slider change (0 to 0.75).
        function handleAmbianceChange(e) {
          const mix = parseFloat(e.target.value);
          setRoomAmbiance(mix);
          if (wetGainRef.current) {
            wetGainRef.current.gain.value = mix;
          }
        }

        // Crowd Ambiance slider change (0 to 1) - Updated to be more robust
        function handleCrowdChange(e) {
          const vol = parseFloat(e.target.value);
          setCrowdVolume(vol);
          console.log("Crowd volume changed to:", vol);
          
          // Handle crossfading scenario
          if (isCrossfadingRef.current) {
            // If we're in the middle of a crossfade, update the volume of the more active track
            if (crowdAudioRef.current && secondaryCrowdAudioRef.current) {
              if (crowdAudioRef.current.volume > secondaryCrowdAudioRef.current.volume) {
                crowdAudioRef.current.volume = vol;
              } else {
                secondaryCrowdAudioRef.current.volume = vol;
              }
            }
          } 
          // Normal scenario (no crossfade)
          else if (crowdAudioRef.current) {
            // Always set the volume, regardless of playback state
            crowdAudioRef.current.volume = vol;
            
            // Also play crowd audio if it's not already playing and volume > 0
            if (vol > 0 && crowdAudioRef.current.paused && crowdAudioRef.current.readyState >= 2) {
              try {
                crowdAudioRef.current.play()
                  .catch(e => console.error("Error starting crowd audio:", e));
              } catch (e) {
                console.error("Error playing crowd audio:", e);
              }
            }
            // Pause if volume is 0
            else if (vol === 0 && !crowdAudioRef.current.paused) {
              crowdAudioRef.current.pause();
            }
          }
        }

        // Completely revised Reference button functionality
        function handleReferenceToggle() {
          if (!audioSourceRef.current || !filtersRef.current) return;
          
          setIsReferenceActive(prev => {
            const newState = !prev;
            
            // If turning reference on - disable all EQ
            if (newState) {
              // Set all filters to 0 gain (bypass all EQ)
              filtersRef.current.forEach(filter => {
                filter.gain.value = 0;
              });
              
              // Start flashing effect for reference button
              if (referenceFlashTimerRef.current) {
                clearInterval(referenceFlashTimerRef.current);
              }
              
              let isVisible = true;
              referenceFlashTimerRef.current = setInterval(() => {
                setIsShowingReference(isVisible);
                isVisible = !isVisible;
              }, 500); // Flash every 500ms
            } 
            // If turning reference off
            else {
              // Stop the flashing effect
              if (referenceFlashTimerRef.current) {
                clearInterval(referenceFlashTimerRef.current);
                referenceFlashTimerRef.current = null;
              }
              
              // First reset all sliders to neutral (visual state)
              setSliders(new Array(activeBandCount).fill(0));
              
              // Then only apply the target EQ modifications directly to filters
              // Reset all filters to 0 first
              filtersRef.current.forEach(filter => {
                filter.gain.value = 0;
              });
              
              // Then apply only target mods (not slider positions)
              targetMods.forEach(mod => {
                if (filtersRef.current[mod.index]) {
                  filtersRef.current[mod.index].gain.value = mod.gain;
                }
              });
              
              setIsShowingReference(false);
            }
            
            return newState;
          });
        }

        // Check if enough song time left before starting a new round
        function checkSongTimeBeforeNewRound() {
          // Only start a new round if there's at least 10 seconds left in the song
          if (audioContextRef.current && audioSourceRef.current && trackDuration > 0) {
            const currentPosition = audioContextRef.current.currentTime - audioSourceRef.current.startTime;
            const timeRemaining = trackDuration - currentPosition;
            
            if (timeRemaining < 10) {
              console.log("Less than 10 seconds left in song, waiting for next track");
              
              // Clear any existing EQ modifications
              if (filtersRef.current) {
                for (let i = 0; i < filtersRef.current.length; i++) {
                  if (filtersRef.current[i]) {
                    filtersRef.current[i].gain.value = 0;
                  }
                }
              }
              
              // Don't start a new round, just wait for next track
              return;
            }
          }
          
          // If we have enough time, start a new round
          startRound();
        }

        // Initialize game over handling
        function handleGameOver() {
          setGameOver(true);
          setFeedback("GAME OVER");
          stopFeedbackOscillator();
          
          // Don't automatically reset - show the continue modal instead
          if (totalScore > hiScore) {
            setHiScore(totalScore);
          }
        }
        
        // Handle the continue option (add 3 lives and continue from same level)
        function handleContinue() {
          // Reset all game state values
          setGameOver(false);
          setFeedback("");
          setLives(3);
          setFeedbackActive(false);
          setFeedbackMode(false);
          setFeedbackSliderIndex(null);
          setIsPlaying(false);
          setRoundScore(null);
          setAttemptsLeft(3);
          setCountdownActive(false);
          setShowingFrequencyHint(false);
          
          // Reset score to 0 while keeping the hi-score
          setTotalScore(0);
          
          // Very important - make sure slider interactions are enabled
          setSliderInteractionDisabled(false);
          
          // Reset all sliders to neutral position
          setSliders(new Array(activeBandCount).fill(0));
          
          // Reset all filters to zero
          if (filtersRef.current) {
            for (let i = 0; i < filtersRef.current.length; i++) {
              if (filtersRef.current[i]) {
                filtersRef.current[i].gain.value = 0;
              }
            }
          }
          
          // Reset any ongoing audio manipulations
          stopFeedbackOscillator();
          if (referenceFlashTimerRef.current) {
            clearInterval(referenceFlashTimerRef.current);
            referenceFlashTimerRef.current = null;
            setIsReferenceActive(false);
            setIsShowingReference(false);
          }
          
          // Clear any timers
          if (timerRef.current) {
            clearInterval(timerRef.current);
            timerRef.current = null;
          }
          if (sliderTimeoutRef.current) {
            clearTimeout(sliderTimeoutRef.current);
            sliderTimeoutRef.current = null;
          }
          
          // Start a completely fresh round at the same level after a short delay
          setTimeout(() => {
            startRound();
          }, 500);
        }
        
        // Handle the restart option (reset everything except hi-score)
        function handleRestart() {
          // Reset all game state values
          setGameOver(false);
          setFeedback("");
          setLives(3);
          setFeedbackActive(false);
          setFeedbackMode(false);
          setFeedbackSliderIndex(null);
          setIsPlaying(false);
          setTotalScore(0);
          setRoundScore(null);
          setAttemptsLeft(3);
          setCountdownActive(false);
          setShowingFrequencyHint(false);
          
          // Very important - make sure slider interactions are enabled
          setSliderInteractionDisabled(false);
          
          // Stop any ongoing feedback oscillator
          stopFeedbackOscillator();
          
          // Clear any reference state
          if (referenceFlashTimerRef.current) {
            clearInterval(referenceFlashTimerRef.current);
            referenceFlashTimerRef.current = null;
          }
          setIsReferenceActive(false);
          setIsShowingReference(false);
          setOriginalFilterGains([]);
          
          // Clear all timers
          if (timerRef.current) {
            clearInterval(timerRef.current);
            timerRef.current = null;
          }
          if (sliderTimeoutRef.current) {
            clearTimeout(sliderTimeoutRef.current);
            sliderTimeoutRef.current = null;
          }
          
          // Reset level to 1 and handle all necessary cleanup
          setLevel(1);
          
          // Calculate the correct number of bands for level 1
          const levelOneBandCount = getActiveBandCount(1);
          
          // Reset the sliders array to match the new band count
          setSliders(new Array(levelOneBandCount).fill(0));
          
          // Reset all filters to zero
          if (filtersRef.current) {
            for (let i = 0; i < filtersRef.current.length; i++) {
              if (filtersRef.current[i]) {
                filtersRef.current[i].gain.value = 0;
              }
            }
          }
          
          // Check if we have audio loaded, and play the first track
          if (audioBuffersRef.current.length > 0) {
            loadCurrentTrack(0, true);
          }
        }

        // Trigger feedback elimination mode with improved state management
        function triggerFeedbackMode() {
          if (attemptsLeft > 1) return false; // Only trigger on the third wrong attempt
          
          console.log("Triggering feedback mode");
          
          // Generate a random slider in the 250-10k range
          const feedbackSlider = generateFeedbackSlider();
          console.log(`Selected feedback slider: ${feedbackSlider} (${freqArray[feedbackSlider].label})`);
          
          // Get the EXACT frequency of the selected band - use the value from the frequency array
          const frequency = freqArray[feedbackSlider].value;
          console.log(`Starting feedback oscillator at ${frequency}`);
          
          // Create feedback target mods
          const feedbackTargetMods = [{
            index: feedbackSlider,
            gain: -12
          }];
          
          // Update state in a more centralized way
          setIsPlaying(false);
          setFeedback(""); // Remove feedback message - just use the red panel and sound
          setFeedbackMode(true);
          setFeedbackActive(true);
          setFeedbackSliderIndex(feedbackSlider);
          setTargetMods(feedbackTargetMods);
          
          // Apply filter changes with our centralized function
          const filterValues = new Array(filtersRef.current.length).fill(0);
          filterValues[feedbackSlider] = -12; // Set only the feedback slider to -12dB
          applyFilterGains(filterValues);
          
          // Start oscillator at the EXACT feedback frequency
          startFeedbackOscillator(frequency);
          
          // Start a 5-second timer for the player to respond
          setTimeout(() => {
            // Only penalize if still in feedback mode after timeout
            if (feedbackActive) {
              console.log("Feedback mode timer expired");
              
              // Stop the oscillator if it's still running
              stopFeedbackOscillator();
              
              setLives(prev => {
                const newLives = prev - 1;
                if (newLives <= 0) {
                  handleGameOver();
                  return 0;
                }
                
                setFeedback("FAILED! MOVE THE SLIDER FASTER NEXT TIME!");
                setTimeout(() => setFeedback(""), 2000);
                return newLives;
              });
              
              // Reset feedback state
              setFeedbackActive(false);
              setFeedbackMode(false);
              applyFilterGains(new Array(filtersRef.current.length).fill(0)); // Reset filter gains
            }
          }, 5000); // 5 seconds to respond
          
          return true;
        }

        // Add this function to create and start the feedback oscillator
        function startFeedbackOscillator(frequency) {
          if (!audioContextRef.current) return;
          
          // Stop any existing oscillator first
          stopFeedbackOscillator();
          
          const ctx = audioContextRef.current;
          
          // Create main oscillator at the band's frequency
          const osc = ctx.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = frequency;
          
          // Create a gain node to control volume for fade in/out
          const gainNode = ctx.createGain();
          gainNode.gain.value = 0; // Start silent
          
          // Connect the oscillator through the gain node to output
          osc.connect(gainNode);
          gainNode.connect(ctx.destination);
          
          // Start oscillator
          osc.start();
          
          // Create 2-second fade in
          const currentTime = ctx.currentTime;
          gainNode.gain.setValueAtTime(0, currentTime);
          gainNode.gain.linearRampToValueAtTime(0.15, currentTime + 2); // 2-second fade in
          
          // Store references - only the oscillator and gain node
          feedbackOscillatorRef.current = osc;
          feedbackGainNodeRef.current = gainNode;
        }

        // Add this function to stop the feedback oscillator
        function stopFeedbackOscillator() {
          if (feedbackOscillatorRef.current && feedbackGainNodeRef.current && audioContextRef.current) {
            try {
              // Create a 1-second fade out
              const currentTime = audioContextRef.current.currentTime;
              feedbackGainNodeRef.current.gain.setValueAtTime(feedbackGainNodeRef.current.gain.value, currentTime);
              feedbackGainNodeRef.current.gain.linearRampToValueAtTime(0, currentTime + 1.0); // 1-second fade out
              
              // Schedule actual stop after fade out completes
              setTimeout(() => {
                try {
                  feedbackOscillatorRef.current.stop();
                  feedbackOscillatorRef.current.disconnect();
                  feedbackGainNodeRef.current.disconnect();
                } catch (e) {
                  console.error("Error during oscillator cleanup:", e);
                }
                
                // Clear references
                feedbackOscillatorRef.current = null;
                feedbackGainNodeRef.current = null;
              }, 1100); // Wait slightly longer than the fade time
              
            } catch (e) {
              console.error("Error stopping oscillator:", e);
              
              // Force cleanup if error occurs
              feedbackOscillatorRef.current = null;
              feedbackGainNodeRef.current = null;
            }
          }
        }

        // Render sliders with the correct highlighting
        return (
          <div style={{ width: "100vw", height: "100vh", position: "relative", overflow: "hidden" }}>
            {/* Show instructions modal on first load */}
            {showInstructions && (
              <InstructionsModal onClose={() => {
                setShowInstructions(false);
                setShowAudioPrompt(true);
              }} />
            )}
            
            {/* Show audio prompt if needed */}
            {!showInstructions && showAudioPrompt && (
              <div className="modalOverlay">
                <div className="modalContent">
                  <h2>Dive Bar Simulator</h2>
                  <p>Please select audio files to start the game</p>
                  <div className="fileInputContainer" style={{ margin: '20px 0' }}>
                    <label htmlFor="initialFileInput" className="fileInputLabel">
                      Choose Audio Files
                    </label>
                    <input 
                      id="initialFileInput"
                      type="file" 
                      accept="audio/*,video/*" 
                      onChange={(e) => {
                        handleFilesChange(e);
                        setShowAudioPrompt(false);
                      }} 
                      multiple 
                    />
                  </div>
                </div>
              </div>
            )}
            
            {/* Top bar with score, difficulty buttons, and hi-score */}
            <div className="scoreDisplay">
              Score: {totalScore}
              {isPlaying && <div style={{color: "yellow", marginTop: "5px"}}>Time: {roundTime}s</div>}
            </div>
            
            {/* Difficulty buttons and Lo-Fi toggle with responsive text labels */}
            <div style={{ 
              position: "absolute",
              top: 28, /* Lowered by 20px */
              left: "50%",
              transform: "translateX(-50%)",
              display: "flex",
              gap: "6px",
              zIndex: 10
            }}>
              <Button 
                onClick={() => setDifficulty('easy')} 
                style={{ 
                  backgroundColor: difficulty === 'easy' ? '#22c55e' : '#6b7280',
                  opacity: difficulty === 'easy' ? 1 : 0.7,
                  padding: "4px 8px",
                  margin: "0",
                  fontSize: "0.6rem"
                }}
              >
                <span className="button-text-short">E</span>
                <span className="button-text-full">EASY</span>
              </Button>
              
              <Button 
                onClick={() => setDifficulty('medium')} 
                style={{ 
                  backgroundColor: difficulty === 'medium' ? '#f97316' : '#6b7280',
                  opacity: difficulty === 'medium' ? 1 : 0.7,
                  padding: "4px 8px",
                  margin: "0",
                  fontSize: "0.6rem"
                }}
              >
                <span className="button-text-short">M</span>
                <span className="button-text-full">MED</span>
              </Button>
              
              <Button 
                onClick={() => setDifficulty('hard')} 
                style={{ 
                  backgroundColor: difficulty === 'hard' ? '#ef4444' : '#6b7280',
                  opacity: difficulty === 'hard' ? 1 : 0.7,
                  padding: "4px 8px",
                  margin: "0",
                  fontSize: "0.6rem"
                }}
              >
                <span className="button-text-short">H</span>
                <span className="button-text-full">HARD</span>
              </Button>
              
              {/* Lo-Fi button with text label */}
              <Button 
                onClick={() => setLofiMode(prev => !prev)} 
                style={{ 
                  backgroundColor: lofiMode ? '#9333ea' : '#6b7280',
                  opacity: lofiMode ? 1 : 0.7,
                  padding: "4px 8px",
                  margin: "0",
                  fontSize: "0.6rem"
                }}
              >
                <span className="button-text-short">L</span>
                <span className="button-text-full">LO-FI</span>
              </Button>
            </div>
            
            <div className="hiScoreDisplay">
              HI-: {hiScore}<br/>
              Lives: {"".repeat(lives)}
            </div>
            
            <div className="eqContainer">
              <div style={{ 
                width: "100%", 
                display: "flex", 
                justifyContent: "center", 
                marginBottom: "10px",
                color: "yellow",
                fontFamily: "'Press Start 2P', cursive",
                fontSize: "1rem" /* Reduced from 1.25rem */
              }}>
                {stageRound.stage}-{stageRound.round}
              </div>
              
              <div className="eqPanel" style={{
                background: feedbackActive ? '#ff0000' : '#1e3a8a', // Only show red during active feedback
                transition: 'background-color 0.5s'
              }}>
                {/* Screws in the four corners */}
                <div className="screw screw-top-left"></div>
                <div className="screw screw-top-right"></div>
                <div className="screw screw-bottom-left"></div>
                <div className="screw screw-bottom-right"></div>
                
                {/* Top horizontal sliders for Volume, Reverb, and Crowd */}
                <div style={{ 
                  display: 'flex', 
                  position: 'absolute',
                  top: '10px',
                  left: '10px',
                  right: '10px',
                  justifyContent: 'space-between',
                  gap: '5px',
                  padding: '0 15px',
                  zIndex: 10
                }}>
                  <div style={{ flex: 1, textAlign: 'center' }}>
                    <label style={{ 
                      fontFamily: "'Press Start 2P', cursive", 
                      fontSize: "0.55rem",
                      color: "white",
                      display: "block",
                      marginBottom: "2px"
                    }}>
                      Volume
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="10"
                      step="1"
                      value={masterVolume}
                      onChange={handleVolumeChange}
                      style={{ width: "100%" }}
                    />
                  </div>
                  
                  <div style={{ flex: 1, textAlign: 'center' }}>
                    <label style={{ 
                      fontFamily: "'Press Start 2P', cursive", 
                      fontSize: "0.55rem",
                      color: "white",
                      display: "block",
                      marginBottom: "2px"
                    }}>
                      Crowd
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="1"
                      step="0.01"
                      value={crowdVolume}
                      onChange={handleCrowdChange}
                      style={{ width: "100%" }}
                    />
                  </div>
                  
                  <div style={{ flex: 1, textAlign: 'center' }}>
                    <label style={{ 
                      fontFamily: "'Press Start 2P', cursive", 
                      fontSize: "0.55rem",
                      color: "white",
                      display: "block",
                      marginBottom: "2px"
                    }}>
                      Reverb
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="0.75"
                      step="0.01"
                      value={roomAmbiance}
                      onChange={handleAmbianceChange}
                      style={{ width: "100%" }}
                    />
                  </div>
                </div>
                
                {freqArray.map((freq, i) => {
                  const label = freq.label;
                  const m = targetMods.find(x => x.index === i);
                  const isTargetSlider = m !== undefined;
                  
                  return (
                    <div key={i} style={{ position: "relative", display: "flex", flexDirection: "column", alignItems: "center" }}>
                      <input
                        type="range"
                        min={-12}
                        max={12}
                        step={0.1}
                        value={sliders[i] || 0}
                        onChange={e => {
                          // Process ALL changes, including clicks and drags
                          handleSliderChange(i, parseFloat(e.target.value));
                        }}
                        onPointerDown={e => {
                          // Just track pointer capture to ensure proper release
                          e.currentTarget.setPointerCapture(e.pointerId);
                        }}
                        onPointerUp={e => {
                          // Release capture when pointer is up
                          e.currentTarget.releasePointerCapture(e.pointerId);
                        }}
                        onPointerCancel={e => {
                          // Also handle pointer cancellation (for touch interfaces)
                          e.currentTarget.releasePointerCapture(e.pointerId);
                        }}
                        style={{
                          width: "34px", /* Slightly narrower slider */
                          height: "200px",
                          background: isTargetSlider ? "red" : "gray",
                          writingMode: "bt-lr",
                          WebkitAppearance: "slider-vertical",
                          cursor: "pointer",
                          margin: "0 3px", /* Smaller margins between sliders */
                          // Add these for better cross-browser compatibility for vertical sliders
                          MozAppearance: "slider-vertical",
                          appearance: "slider-vertical"
                        }}
                      />
                      {/* Show yellow target dot ONLY if debug mode is on */}
                      {(debugMode && (isTargetSlider || (feedbackActive && i === feedbackSliderIndex))) && (
                        <div className="targetDot" style={{ 
                          position: "absolute",
                          width: "10px",
                          height: "10px",
                          borderRadius: "50%",
                          backgroundColor: "yellow",
                          top: feedbackActive && i === feedbackSliderIndex ? 
                                `calc(100% - 5px)` : // Position at bottom to indicate -12dB
                                `${((12 - (-m?.gain || 0)) / 24) * 200}px`,
                          pointerEvents: 'none'
                        }}></div>
                      )}
                      <label style={{ 
                        fontFamily: "'Press Start 2P', cursive", 
                        fontSize: "0.6rem", /* Smaller font for labels */
                        marginTop: "4px", 
                        maxWidth: "30px", /* Restrict width of labels */
                        textAlign: "center",
                        overflow: "hidden",
                        whiteSpace: "nowrap"
                      }}>
                        {label}
                      </label>
                    </div>
                  );
                })}
              </div>
              
              {/* Game control buttons */}
              <div style={{ width: "100%", display: "flex", justifyContent: "center", marginTop: "16px", gap: "12px" }}>
                {/* Reference button stays visible always when playing audio */}
                <Button 
                  onClick={handleReferenceToggle} 
                  disabled={audioPlayerState !== 'playing'}
                  style={{ 
                    background: isShowingReference ? '#22c55e' : '#3b82f6',
                    animation: isReferenceActive ? 'pulse 1s infinite' : 'none',
                    padding: '6px 10px',
                    fontSize: '0.7rem'
                  }}
                >
                  <span className="button-text-short">REF</span>
                  <span className="button-text-full">REFERENCE</span>
                </Button>
                
                {/* Start Round button appears only when audio is playing but round not started */}
                {audioPlayerState === 'playing' && !isPlaying && (
                  <Button 
                    onClick={() => startRound()}
                    style={{ 
                      background: '#22c55e',
                      padding: '6px 10px',
                      fontSize: '0.7rem' 
                    }}
                  >
                    <span className="button-text-short">GO!</span>
                    <span className="button-text-full">START ROUND</span>
                  </Button>
                )}
                {/* No Submit button as per requirement #5 - auto-checks after 1.5s */}
              </div>
              
              {/* Transport controls with responsive labels */}
              <div className="transportControls">
                <Button 
                  onClick={handlePrevTrack} 
                  disabled={audioFiles.length < 2}
                  style={{ padding: "6px 10px" }}
                >
                  <span className="button-text-short"></span>
                  <span className="button-text-full">PREV</span>
                </Button>
                <Button 
                  onClick={handlePlay} 
                  disabled={audioFiles.length === 0}
                  style={{ padding: "6px 10px" }}
                >
                  <span className="button-text-short"></span>
                  <span className="button-text-full">PLAY</span>
                </Button>
                <Button 
                  onClick={handlePause} 
                  disabled={audioPlayerState === 'stopped'}
                  style={{ padding: "6px 10px" }}
                >
                  <span className="button-text-short"></span>
                  <span className="button-text-full">PAUSE</span>
                </Button>
                <Button 
                  onClick={handleStop} 
                  disabled={audioPlayerState === 'stopped'}
                  style={{ padding: "6px 10px" }}
                >
                  <span className="button-text-short"></span>
                  <span className="button-text-full">STOP</span>
                </Button>
                <Button 
                  onClick={handleNextTrack} 
                  disabled={audioFiles.length < 2}
                  style={{ padding: "6px 10px" }}
                >
                  <span className="button-text-short"></span>
                  <span className="button-text-full">NEXT</span>
                </Button>
                <Button 
                  onClick={shuffleTracks}
                  disabled={audioFiles.length < 2}
                  className="shuffleButton"
                  style={{ padding: "6px 10px" }}
                >
                  <span className="button-text-short"></span>
                  <span className="button-text-full">SHUFFLE</span>
                </Button>
              </div>
              
              {/* Track position slider */}
              <div className="trackSlider">
                <input
                  type="range"
                  min="0"
                  max={trackDuration || 1}
                  step="0.1"
                  value={trackPosition || 0}
                  onChange={handlePositionChange}
                  style={{ width: "100%" }}
                  disabled={audioBuffersRef.current.length === 0}
                />
                <div className="trackInfo">
                  <span>{formatTime(trackPosition || 0)}</span>
                  <span>{formatTime(trackDuration || 0)}</span>
                </div>
              </div>
              
              {/* File input moved below EQ panel */}
              <div className="fileInputContainer">
                <label htmlFor="fileInput" className="fileInputLabel">
                  Choose Audio Files
                </label>
                <input 
                  id="fileInput"
                  type="file" 
                  accept="audio/*,video/*" 
                  onChange={handleFilesChange} 
                  multiple 
                />
                {audioFiles.length > 0 && (
                  <span className="fileName">{audioFiles.length} file(s) selected</span>
                )}
              </div>
              
              {/* Playlist */}
              {audioFiles.length > 0 && (
                <div className="playlistContainer">
                  {audioFiles.map((file, i) => (
                    <div 
                      key={i}
                      className={`playlistItem ${i === currentTrackIndex ? 'active' : ''}`}
                      onClick={() => playTrack(i)}
                    >
                      {i + 1}. {file.name}
                    </div>
                  ))}
                </div>
              )}
            </div>
            
            {/* Bottom controls: Room Ambiance, Volume, and Crowd Ambiance */}
            <div className="bottomControls" style={{ display: 'none' }}>
              {/* Controls removed - now at top of EQ panel */}
            </div>
            
            {/* Crowd ambiance audio element (preloaded) */}
            <audio ref={crowdAudioRef} preload="auto" style={{ display: "none" }}>
              <source src="CROWDNOISE.mp3" type="audio/mp3" />
            </audio>

            {/* Game Over Modal */}
            {gameOver && (
              <div className="modalOverlay">
                <div className="modalContent">
                  <h2>Game Over</h2>
                  <p>Your score: {totalScore}</p>
                  <div className="modalButtons">
                    <Button onClick={handleContinue} style={{ background: '#22c55e' }}>Continue</Button>
                    <Button onClick={handleRestart} style={{ background: '#ef4444' }}>Restart</Button>
                  </div>
                </div>
              </div>
            )}

            {/* Modified overlays to ensure they're fully visible */}
            {countdownActive && (
              <div className="countdownOverlay">{countdownText}</div>
            )}
            
            {feedback && !feedback.includes("LEFT") && (
              <div className="feedbackOverlay">{feedback}</div>
            )}
            
            {/* Special styling for life loss messages - now clickable */}
            {!isPlaying && feedback && feedback.includes("LEFT") && (
              <div 
                onClick={() => {
                  // Restart the current track from the beginning
                  if (audioSourceRef.current && audioContextRef.current) {
                    try {
                      // Stop current playback
                      audioSourceRef.current.stop();
                    } catch (e) {}
                    
                    // Load current track from beginning and play it
                    loadCurrentTrack(currentTrackIndex, true);
                  }
                  
                  // Clear feedback and start a new round
                  setFeedback("");
                  startRound();
                }}
                style={{
                  position: "fixed",
                  top: "50%",
                  left: "50%",
                  transform: "translate(-50%, -50%)",
                  width: "80%",
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "center",
                  alignItems: "center",
                  fontSize: "2rem",
                  color: "#ff3333", /* Bright red color */
                  fontFamily: "'Press Start 2P', cursive",
                  textAlign: "center",
                  padding: "30px",
                  fontWeight: "bold",
                  textShadow: "2px 2px 0px #000",
                  backgroundColor: "rgba(0, 0, 0, 0.9)", /* More opaque background */
                  zIndex: 200, /* Highest z-index */
                  pointerEvents: "auto", /* Changed from none to auto to make clickable */
                  borderRadius: "20px",
                  border: "4px solid #ff3333",
                  cursor: "pointer" /* Add cursor pointer to indicate it's clickable */
                }}
              >
                {feedback}
                <div style={{ 
                  fontSize: "1rem", 
                  marginTop: "15px",
                  color: "#ffffff"
                }}>
                  CLICK TO CONTINUE
                </div>
              </div>
            )}
            
            {showingFrequencyHint && (
              <div className="hintOverlay">{frequencyHintText}</div>
            )}
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
